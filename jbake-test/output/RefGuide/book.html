<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Apache Solr Reference Guide</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">
    <link href="../css/ref-guide.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">JBake</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../feed.xml">Subscribe</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="#">Action</a></li>
                <li><a href="#">Another action</a></li>
                <li><a href="#">Something else here</a></li>
                <li class="divider"></li>
                <li class="dropdown-header">Nav header</li>
                <li><a href="#">Separated link</a></li>
                <li><a href="#">One more separated link</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
	<div class="page-header">
		<h1>Apache Solr Reference Guide</h1>
	</div>

	<p><h1 id="_about_filters" class="sect0">About Filters</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Like <a href="Tokenizers.html">tokenizers</a>, <a href="Filter-Descriptions.html">filters</a> consume input and produce a stream of tokens. Filters also derive from <code>org.apache.lucene.analysis.TokenStream</code>. Unlike tokenizers, a filter&#8217;s input is another TokenStream. The job of a filter is usually easier than that of a tokenizer since in most cases a filter looks at each token in the stream sequentially and decides whether to pass it along, replace it or discard it.</p>
</div>
<div class="paragraph">
<p>A filter may also do more complex analysis by looking ahead to consider multiple tokens at once, although this is less common. One hypothetical use for such a filter might be to normalize state names that would be tokenized as two words. For example, the single token "california" would be replaced with "CA", while the token pair "rhode" followed by "island" would become the single token "RI".</p>
</div>
<div class="paragraph">
<p>Because filters consume one <code>TokenStream</code> and produce a new <code>TokenStream</code>, they can be chained one after another indefinitely. Each filter in the chain in turn processes the tokens produced by its predecessor. The order in which you specify the filters is therefore significant. Typically, the most general filtering is done first, and later filtering stages are more specialized.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.EnglishPorterFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This example starts with Solr&#8217;s standard tokenizer, which breaks the field&#8217;s text into tokens. Those tokens then pass through Solr&#8217;s standard filter, which removes dots from acronyms, and performs a few other common operations. All the tokens are then set to lowercase, which will facilitate case-insensitive matching at query time.</p>
</div>
<div class="paragraph">
<p>The last filter in the above example is a stemmer filter that uses the Porter stemming algorithm. A stemmer is basically a set of mapping rules that maps the various forms of a word back to the base, or <em>stem</em>, word from which they derive. For example, in English the words "hugs", "hugging" and "hugged" are all forms of the stem word "hug". The stemmer will replace all of these terms with "hug", which is what will be indexed. This means that a query for "hug" will match the term "hugged", but not "huge".</p>
</div>
<div class="paragraph">
<p>Conversely, applying a stemmer to your query terms will allow queries containing non stem terms, like "hugging", to match documents with different variations of the same stem word, such as "hugged". This works because both the indexer and the query will map to the same stem ("hug").</p>
</div>
<div class="paragraph">
<p>Word stemming is, obviously, very language specific. Solr includes several language-specific stemmers created by the <a href="http://snowball.tartarus.org/">Snowball</a> generator that are based on the Porter stemming algorithm. The generic Snowball Porter Stemmer Filter can be used to configure any of these language stemmers. Solr also includes a convenience wrapper for the English Snowball stemmer. There are also several purpose-built stemmers for non-English languages. These stemmers are described in <a href="Language-Analysis.html">Language Analysis</a>.</p>
</div>
</div>
</div>
<h1 id="_index_replication" class="sect0">Index Replication</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Index Replication distributes complete copies of a master index to one or more slave servers. The master server continues to manage updates to the index. All querying is handled by the slaves. This division of labor enables Solr to scale to provide adequate responsiveness to queries against large search volumes.</p>
</div>
<div class="paragraph">
<p>The figure below shows a Solr configuration using index replication. The master server&#8217;s index is replicated on the slaves.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/attachments/32604221/32702467.png" alt="32702467">
</div>
<div class="title">Figure 1. <em>A Solr index can be replicated across multiple slave servers, which then processes requests.</em></div>
</div>
<div class="paragraph">
<p>Topics covered in this section:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#IndexReplication-IndexReplicationinSolr">Index Replication in Solr</a></p>
</li>
<li>
<p><a href="#IndexReplication-ReplicationTerminology">Replication Terminology</a></p>
</li>
<li>
<p><a href="#IndexReplication-ConfiguringtheReplicationHandler">Configuring the ReplicationHandler</a></p>
</li>
<li>
<p><a href="#IndexReplication-SettingUpaRepeaterwiththeReplicationHandler">Setting Up a Repeater with the ReplicationHandler</a></p>
</li>
<li>
<p><a href="#IndexReplication-CommitandOptimizeOperations">Commit and Optimize Operations</a></p>
</li>
<li>
<p><a href="#IndexReplication-SlaveReplication">Slave Replication</a></p>
</li>
<li>
<p><a href="#IndexReplication-HTTPAPICommandsfortheReplicationHandler">HTTP API Commands for the ReplicationHandler</a></p>
</li>
<li>
<p><a href="#IndexReplication-DistributionandOptimization">Distribution and Optimization</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-IndexReplicationinSolr">Index Replication in Solr</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Solr includes a Java implementation of index replication that works over HTTP:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The configuration affecting replication is controlled by a single file, <code>solrconfig.xml</code></p>
</li>
<li>
<p>Supports the replication of configuration files as well as index files</p>
</li>
<li>
<p>Works across platforms with same configuration</p>
</li>
<li>
<p>No reliance on OS-dependent file system features (eg: hard links)</p>
</li>
<li>
<p>Tightly integrated with Solr; an admin page offers fine-grained control of each aspect of replication</p>
</li>
<li>
<p>The Java-based replication feature is implemented as a request handler. Configuring replication is therefore similar to any normal request handler.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_replication_in_solrcloud">Replication In SolrCloud</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Although there is no explicit concept of "master/slave" nodes in a <a href="SolrCloud.html">SolrCloud</a> cluster, the <code>ReplicationHandler</code> discussed on this page is still used by SolrCloud as needed to support "shard recovery" – but this is done in a peer to peer manner. When using SolrCloud, the <code>ReplicationHandler</code> must be available via the <code>/replication</code> path. Solr does this implicitly unless overridden explicitly in your <code>solrconfig.xml</code>, but If you wish to override the default behavior, make certain that you do not explicitly set any of the "master" or "slave" configuration options mentioned below, or they will interfere with normal SolrCloud operation.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-ReplicationTerminology">Replication Terminology</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The table below defines the key terms associated with Solr replication.</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Term</th>
<th class="tableblock halign-left valign-top">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Lucene index is a directory of files. These files make up the searchable and returnable data of a Solr Core.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Distribution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The copying of an index from the master server to all slaves. The distribution process takes advantage of Lucene&#8217;s index file structure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserts and Deletes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">As inserts and deletes occur in the index, the directory remains unchanged. Documents are always inserted into newly created files. Documents that are deleted are not removed from the files. They are flagged in the file, deletable, and are not removed from the files until the index is optimized.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Master and Slave</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Solr replication master is a single node which receives all updates initially and keeps everything organized. Solr replication slave nodes receive no updates directly, instead all changes (such as inserts, updates, deletes, etc.) are made against the single master node. Changes made on the master are distributed to all the slave nodes which service all query requests from the clients.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Update</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An update is a single change request against a single Solr instance. It may be a request to delete a document, add a new document, change a document, delete all documents matching a query, etc. Updates are handled synchronously within an individual Solr instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optimization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A process that compacts the index and merges segments in order to improve query performance. Optimization should only be run on the master nodes. An optimized index may give query performance gains compared to an index that has become fragmented over a period of time with many updates. Distributing an optimized index requires a much longer time than the distribution of new segments to an un-optimized index.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Segments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A self contained subset of an index consisting of some documents and data structures related to the inverted index of terms in those documents.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mergeFactor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A parameter that controls the number of segments in an index. For example, when mergeFactor is set to 3, Solr will fill one segment with documents until the limit maxBufferedDocs is met, then it will start a new segment. When the number of segments specified by mergeFactor is reached (in this example, 3) then Solr will merge all the segments into a single index file, then begin writing new documents to a new segment.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Snapshot</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A directory containing hard links to the data files of an index. Snapshots are distributed from the master nodes when the slaves pull them, "smart copying" any segments the slave node does not have in snapshot directory that contains the hard links to the most recent index data files.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-ConfiguringtheReplicationHandler">Configuring the ReplicationHandler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to <code>ReplicationHandler</code> configuration options specific to the master/slave roles, there are a few special configuration options that are generally supported (even when using SolrCloud).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>maxNumberOfBackups</code> an integer value dictating the maximum number of backups this node will keep on disk as it receives <code>backup</code> commands.</p>
</li>
<li>
<p>Similar to most other request handlers in Solr you may configure a set of "<a href="RequestHandlers-and-SearchComponents-in-SolrConfig.html#RequestHandlersandSearchComponentsinSolrConfig-SearchHandlers">defaults, invariants, and/or appends</a>" parameters corresponding with any request parameters supported by the <code>ReplicationHandler</code> when <a href="#IndexReplication-HTTPAPICommandsfortheReplicationHandler">processing commands</a>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="IndexReplication-ConfiguringtheReplicationRequestHandleronaMasterServer">Configuring the Replication RequestHandler on a Master Server</h3>
<div class="paragraph">
<p>Before running a replication, you should set the following parameters on initialization of the handler:</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">replicateAfter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String specifying action after which replication should occur. Valid values are commit, optimize, or startup. There can be multiple values for this parameter. If you use "startup", you need to have a "commit" and/or "optimize" entry also if you want to trigger replication on future commits or optimizes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">backupAfter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String specifying action after which a backup should occur. Valid values are commit, optimize, or startup. There can be multiple values for this parameter. It is not required for replication, it just makes a backup.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maxNumberOfBackups</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer specifying how many backups to keep. This can be used to delete all but the most recent N backups.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">confFiles</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The configuration files to replicate, separated by a comma.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">commitReserveDuration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If your commits are very frequent and your network is slow, you can tweak this parameter to increase the amount of time taken to download 5Mb from the master to a slave. The default is 10 seconds.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The example below shows a possible 'master' configuration for the <code>ReplicationHandler</code>, including a fixed number of backups and an invariant setting for the <code>maxWriteMBPerSec</code> request parameter to prevent slaves from saturating it&#8217;s network interface</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;requestHandler</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/replication</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ReplicationHandler</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;lst</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">master</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replicateAfter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>optimize<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">backupAfter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>optimize<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">confFiles</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>schema.xml,stopwords.txt,elevate.xml<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">commitReserveDuration</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>00:00:10<span class="tag">&lt;/str&gt;</span>
  <span class="tag">&lt;/lst&gt;</span>
  <span class="tag">&lt;int</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxNumberOfBackups</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>2<span class="tag">&lt;/int&gt;</span>
  <span class="tag">&lt;lst</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">invariants</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxWriteMBPerSec</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>16<span class="tag">&lt;/str&gt;</span>
  <span class="tag">&lt;/lst&gt;</span>
<span class="tag">&lt;/requestHandler&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IndexReplication-Replicatingsolrconfig.xml">Replicating <code>solrconfig.xml</code></h3>
<div class="paragraph">
<p>In the configuration file on the master server, include a line like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">confFiles</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>solrconfig_slave.xml:solrconfig.xml,x.xml,y.xml<span class="tag">&lt;/str&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This ensures that the local configuration <code>solrconfig_slave.xml</code> will be saved as <code>solrconfig.xml</code> on the slave. All other files will be saved with their original names.</p>
</div>
<div class="paragraph">
<p>On the master server, the file name of the slave configuration file can be anything, as long as the name is correctly identified in the <code>confFiles</code> string; then it will be saved as whatever file name appears after the colon, ":".</p>
</div>
</div>
<div class="sect2">
<h3 id="IndexReplication-ConfiguringtheReplicationRequestHandleronaSlaveServer">Configuring the Replication RequestHandler on a Slave Server</h3>
<div class="paragraph">
<p>The code below shows how to configure a ReplicationHandler on a slave.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;requestHandler</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/replication</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ReplicationHandler</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;lst</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">slave</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

    <span class="comment">&lt;!-- fully qualified url for the replication handler of master. It is
         possible to pass on this as a request param for the fetchindex command --&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterUrl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>http://remote_host:port/solr/core_name/replication<span class="tag">&lt;/str&gt;</span>

    <span class="comment">&lt;!-- Interval in which the slave should poll master.  Format is HH:mm:ss .
         If this is absent slave does not poll automatically.

         But a fetchindex can be triggered from the admin or the http API --&gt;</span>

    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pollInterval</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>00:00:20<span class="tag">&lt;/str&gt;</span>

    <span class="comment">&lt;!-- THE FOLLOWING PARAMETERS ARE USUALLY NOT REQUIRED--&gt;</span>

    <span class="comment">&lt;!-- To use compression while transferring the index files. The possible
         values are internal|external.  If the value is 'external' make sure
         that your master Solr has the settings to honor the accept-encoding header.
         See here for details: http://wiki.apache.org/solr/SolrHttpCompression
         If it is 'internal' everything will be taken care of automatically.
         USE THIS ONLY IF YOUR BANDWIDTH IS LOW.
         THIS CAN ACTUALLY SLOWDOWN REPLICATION IN A LAN --&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">compression</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>internal<span class="tag">&lt;/str&gt;</span>

    <span class="comment">&lt;!-- The following values are used when the slave connects to the master to
         download the index files.  Default values implicitly set as 5000ms and
         10000ms respectively. The user DOES NOT need to specify these unless the
         bandwidth is extremely low or if there is an extremely high latency --&gt;</span>

    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">httpConnTimeout</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>5000<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">httpReadTimeout</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>10000<span class="tag">&lt;/str&gt;</span>

    <span class="comment">&lt;!-- If HTTP Basic authentication is enabled on the master, then the slave
         can be configured with the following --&gt;</span>

    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">httpBasicAuthUser</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>username<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">httpBasicAuthPassword</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>password<span class="tag">&lt;/str&gt;</span>
  <span class="tag">&lt;/lst&gt;</span>
<span class="tag">&lt;/requestHandler&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-SettingUpaRepeaterwiththeReplicationHandler">Setting Up a Repeater with the ReplicationHandler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A master may be able to serve only so many slaves without affecting performance. Some organizations have deployed slave servers across multiple data centers. If each slave downloads the index from a remote data center, the resulting download may consume too much network bandwidth. To avoid performance degradation in cases like this, you can configure one or more slaves as repeaters. A repeater is simply a node that acts as both a master and a slave.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To configure a server as a repeater, the definition of the Replication <code>requestHandler</code> in the <code>solrconfig.xml</code> file must include file lists of use for both masters and slaves.</p>
</li>
<li>
<p>Be sure to set the <code>replicateAfter</code> parameter to commit, even if <code>replicateAfter</code> is set to optimize on the main master. This is because on a repeater (or any slave), a commit is called only after the index is downloaded. The optimize command is never called on slaves.</p>
</li>
<li>
<p>Optionally, one can configure the repeater to fetch compressed files from the master through the compression parameter to reduce the index download time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example of a ReplicationHandler configuration for a repeater:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;requestHandler</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/replication</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ReplicationHandler</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;lst</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">master</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replicateAfter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>commit<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">confFiles</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>schema.xml,stopwords.txt,synonyms.txt<span class="tag">&lt;/str&gt;</span>
  <span class="tag">&lt;/lst&gt;</span>
  <span class="tag">&lt;lst</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">slave</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterUrl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>http://master.solr.company.com:8983/solr/core_name/replication<span class="tag">&lt;/str&gt;</span>
    <span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pollInterval</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>00:00:60<span class="tag">&lt;/str&gt;</span>
  <span class="tag">&lt;/lst&gt;</span>
<span class="tag">&lt;/requestHandler&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-CommitandOptimizeOperations">Commit and Optimize Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a commit or optimize operation is performed on the master, the RequestHandler reads the list of file names which are associated with each commit point. This relies on the <code>replicateAfter</code> parameter in the configuration to decide which types of events should trigger replication.</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting on the Master</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">commit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Triggers replication whenever a commit is performed on the master index.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">optimize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Triggers replication whenever the master index is optimized.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">startup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Triggers replication whenever the master index starts up.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The replicateAfter parameter can accept multiple arguments. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replicateAfter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>startup<span class="tag">&lt;/str&gt;</span>
<span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replicateAfter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>commit<span class="tag">&lt;/str&gt;</span>
<span class="tag">&lt;str</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replicateAfter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>optimize<span class="tag">&lt;/str&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-SlaveReplication">Slave Replication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The master is totally unaware of the slaves. The slave continuously keeps polling the master (depending on the <code>pollInterval</code> parameter) to check the current index version of the master. If the slave finds out that the master has a newer version of the index it initiates a replication process. The steps are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The slave issues a <code>filelist</code> command to get the list of the files. This command returns the names of the files as well as some metadata (for example, size, a lastmodified timestamp, an alias if any).</p>
</li>
<li>
<p>The slave checks with its own index if it has any of those files in the local index. It then runs the filecontent command to download the missing files. This uses a custom format (akin to the HTTP chunked encoding) to download the full content or a part of each file. If the connection breaks in between, the download resumes from the point it failed. At any point, the slave tries 5 times before giving up a replication altogether.</p>
</li>
<li>
<p>The files are downloaded into a temp directory, so that if either the slave or the master crashes during the download process, no files will be corrupted. Instead, the current replication will simply abort.</p>
</li>
<li>
<p>After the download completes, all the new files are moved to the live index directory and the file&#8217;s timestamp is same as its counterpart on the master.</p>
</li>
<li>
<p>A commit command is issued on the slave by the Slave&#8217;s ReplicationHandler and the new index is loaded.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="IndexReplication-ReplicatingConfigurationFiles">Replicating Configuration Files</h3>
<div class="paragraph">
<p>To replicate configuration files, list them using using the <code>confFiles</code> parameter. Only files found in the <code>conf</code> directory of the master&#8217;s Solr instance will be replicated.</p>
</div>
<div class="paragraph">
<p>Solr replicates configuration files only when the index itself is replicated. That means even if a configuration file is changed on the master, that file will be replicated only after there is a new commit/optimize on master&#8217;s index.</p>
</div>
<div class="paragraph">
<p>Unlike the index files, where the timestamp is good enough to figure out if they are identical, configuration files are compared against their checksum. The <code>schema.xml</code> files (on master and slave) are judged to be identical if their checksums are identical.</p>
</div>
<div class="paragraph">
<p>As a precaution when replicating configuration files, Solr copies configuration files to a temporary directory before moving them into their ultimate location in the conf directory. The old configuration files are then renamed and kept in the same <code>conf/</code> directory. The ReplicationHandler does not automatically clean up these old files.</p>
</div>
<div class="paragraph">
<p>If a replication involved downloading of at least one configuration file, the ReplicationHandler issues a core-reload command instead of a commit command.</p>
</div>
</div>
<div class="sect2">
<h3 id="IndexReplication-ResolvingCorruptionIssuesonSlaveServers">Resolving Corruption Issues on Slave Servers</h3>
<div class="paragraph">
<p>If documents are added to the slave, then the slave is no longer in sync with its master. However, the slave will not undertake any action to put itself in sync, until the master has new index data. When a commit operation takes place on the master, the index version of the master becomes different from that of the slave. The slave then fetches the list of files and finds that some of the files present on the master are also present in the local index but with different sizes and timestamps. This means that the master and slave have incompatible indexes. To correct this problem, the slave then copies all the index files from master to a new index directory and asks the core to load the fresh index from the new directory.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-HTTPAPICommandsfortheReplicationHandler">HTTP API Commands for the ReplicationHandler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use the HTTP commands below to control the ReplicationHandler&#8217;s operations.</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Command</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>master_host:port</em>/solr/<em>core_name</em>/replication?command=enablereplication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables replication on the master for all its slaves.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>master_host:port</em>/solr/<em>core_name</em>/replication?command=disablereplication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disables replication on the master for all its slaves.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>host:port</em>/solr/<em>core_name</em>/replication?command=indexversion</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the version of the latest replicatable index on the specified master or slave.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>slave_host:port</em>/solr/<em>core_name</em>/replication?command=fetchindex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Forces the specified slave to fetch a copy of the index from its master. If you like, you can pass an extra attribute such as masterUrl or compression (or any other parameter which is specified in the <code>&lt;lst name="slave"&gt;</code> tag) to do a one time replication from a master. This obviates the need for hard-coding the master in the slave.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>slave_host:port</em>/solr/<em>core_name</em>/replication?command=abortfetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aborts copying an index from a master to the specified slave.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>slave_host:port</em>/solr/<em>core_name</em>/replication?command=enablepoll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables the specified slave to poll for changes on the master.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>slave_host:port</em>/solr/<em>core_name</em>/replication?command=disablepoll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disables the specified slave from polling for changes on the master.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>slave_host:port</em>/solr/<em>core_name</em>/replication?command=details</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves configuration details and current status.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>host:port</em>/solr/<em>core_name</em>/replication?command=filelist&amp;indexversion=&lt;<em>index-version-number</em>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieves a list of Lucene files present in the specified host&#8217;s index. You can discover the version number of the index by running the <code>indexversion</code> command.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>master_host:port</em>/solr/<em>core_name</em>/replication?command=backup</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Creates a backup on master if there are committed index data in the server; otherwise, does nothing. This command is useful for making periodic backups.</p>
</div>
<div class="paragraph">
<p>supported request parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>numberToKeep:</code> request parameter can be used with the backup command unless the <code>maxNumberOfBackups</code> initialization parameter has been specified on the handler – in which case <code>maxNumberOfBackups</code> is always used and attempts to use the <code>numberToKeep</code> request parameter will cause an error.</p>
</li>
<li>
<p><code>name</code> : (optional) Backup name . The snapshot will be created in a directory called snapshot.&lt;name&gt; within the data directory of the core . By default the name is generated using date in <code>yyyyMMddHHmmssSSS</code> format. If <code>location</code> parameter is passed , that would be used instead of the data directory</p>
</li>
<li>
<p>` location ` : Backup location</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http://<em>master_host:port</em> /solr/<em>core_name</em>/replication?command=deletebackup</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Delete any backup created using the <code>backup</code> command .</p>
</div>
<div class="paragraph">
<p>request parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>name: The name of the snapshot . A snapshot with the name snapshot.&lt;name&gt; must exist .If not, an error is thrown</p>
</li>
<li>
<p>location: Location where the snapshot is created</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="IndexReplication-DistributionandOptimization">Distribution and Optimization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Optimizing an index is not something most users should generally worry about - but in particular users should be aware of the impacts of optimizing an index when using the <code>ReplicationHandler</code>.</p>
</div>
<div class="paragraph">
<p>The time required to optimize a master index can vary dramatically. A small index may be optimized in minutes. A very large index may take hours. The variables include the size of the index and the speed of the hardware.</p>
</div>
<div class="paragraph">
<p>Distributing a newly optimized index may take only a few minutes or up to an hour or more, again depending on the size of the index and the performance capabilities of network connections and disks. During optimization the machine is under load and does not process queries very well. Given a schedule of updates being driven a few times an hour to the slaves, we cannot run an optimize with every committed snapshot.</p>
</div>
<div class="paragraph">
<p>Copying an optimized index means that the <strong>entire</strong> index will need to be transferred during the next snappull. This is a large expense, but not nearly as huge as running the optimize everywhere. Consider this example: on a three-slave one-master configuration, distributing a newly-optimized index takes approximately 80 seconds <em>total</em>. Rolling the change across a tier would require approximately ten minutes per machine (or machine group). If this optimize were rolled across the query tier, and if each slave node being optimized were disabled and not receiving queries, a rollout would take at least twenty minutes and potentially as long as an hour and a half. Additionally, the files would need to be synchronized so that the <em>following</em> the optimize, snappull would not think that the independently optimized files were different in any way. This would also leave the door open to independent corruption of indexes instead of each being a perfect copy of the master.</p>
</div>
<div class="paragraph">
<p>Optimizing on the master allows for a straight-forward optimization operation. No query slaves need to be taken out of service. The optimized index can be distributed in the background as queries are being normally serviced. The optimization can occur at any time convenient to the application providing index updates.</p>
</div>
<div class="paragraph">
<p>While optimizing may have some benefits in some situations, a rapidly changing index will not retain those benefits for long, and since optimization is an intensive process, it may be better to consider other options, such as lowering the merge factor (discussed in the section on <a href="IndexConfig-in-SolrConfig.html#IndexConfiginSolrConfig-mergeFactor">Index Configuration</a>).</p>
</div>
</div>
</div>
<h1 id="_language_analysis" class="sect0">Language Analysis</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This section contains information about tokenizers and filters related to character set conversion or for use with specific languages. For the European languages, tokenization is fairly straightforward. Tokens are delimited by white space and/or a relatively small set of punctuation characters. In other languages the tokenization rules are often not so simple. Some European languages may require special tokenization rules as well, such as rules for decompounding German words.</p>
</div>
<div class="paragraph">
<p>For information about language detection at index time, see <a href="Detecting-Languages-During-Indexing.html">Detecting Languages During Indexing</a>.</p>
</div>
<div class="paragraph">
<p>Topics discussed in this section:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#LanguageAnalysis-KeywordMarkerFilterFactory">KeywordMarkerFilterFactory</a></p>
</li>
<li>
<p><a href="#LanguageAnalysis-StemmerOverrideFilterFactory">StemmerOverrideFilterFactory</a></p>
</li>
<li>
<p><a href="#LanguageAnalysis-DictionaryCompoundWordTokenFilter">Dictionary Compound Word Token Filter</a></p>
</li>
<li>
<p><a href="#LanguageAnalysis-UnicodeCollation">Unicode Collation</a></p>
</li>
<li>
<p><a href="#LanguageAnalysis-ASCIIFoldingFilter">ASCII Folding Filter</a></p>
</li>
<li>
<p><a href="#LanguageAnalysis-Language-SpecificFactories">Language-Specific Factories</a></p>
</li>
<li>
<p><a href="#LanguageAnalysis-RelatedTopics">Related Topics</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="LanguageAnalysis-KeywordMarkerFilterFactory">KeywordMarkerFilterFactory</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Protects words from being modified by stemmers. A customized protected word list may be specified with the "protected" attribute in the schema. Any words in the protected word list will not be modified by any stemmer in Solr.</p>
</div>
<div class="paragraph">
<p>A sample Solr <code>protwords.txt</code> with comments can be found in the <code>sample_techproducts_configs</code> <a href="Config-Sets.html">config set</a> directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldtype</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myfieldtype</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.KeywordMarkerFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">protected</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">protwords.txt</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PorterStemFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldtype&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="LanguageAnalysis-StemmerOverrideFilterFactory">StemmerOverrideFilterFactory</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Overrides stemming algorithms by applying a custom mapping, then protecting these terms from being modified by stemmers.</p>
</div>
<div class="paragraph">
<p>A customized mapping of words to stems, in a tab-separated file, can be specified to the "dictionary" attribute in the schema. Words in this mapping will be stemmed to the stems from the file, and will not be further changed by any stemmer.</p>
</div>
<div class="paragraph">
<p>A sample <a href="http://svn.apache.org/repos/asf/lucene/dev/trunk/solr/core/src/test-files/solr/collection1/conf/stemdict.txt">stemdict.txt</a> with comments can be found in the Source Repository.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldtype</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myfieldtype</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StemmerOverrideFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">dictionary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">stemdict.txt</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PorterStemFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldtype&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="LanguageAnalysis-DictionaryCompoundWordTokenFilter">Dictionary Compound Word Token Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter splits, or <em>decompounds</em>, compound words into individual words using a dictionary of the component words. Each input token is passed through unchanged. If it can also be decompounded into subwords, each subword is also added to the stream at the same logical position.</p>
</div>
<div class="paragraph">
<p>Compound words are most commonly found in Germanic languages.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.DictionaryCompoundWordTokenFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>dictionary</code></dt>
<dd>
<p>(required) The path of a file that contains a list of simple words, one per line. Blank lines and lines that begin with "#" are ignored. This path may be an absolute path, or path relative to the Solr config directory.</p>
</dd>
<dt class="hdlist1"><code>minWordSize</code></dt>
<dd>
<p>(integer, default 5) Any token shorter than this is not decompounded.</p>
</dd>
<dt class="hdlist1"><code>minSubwordSize</code></dt>
<dd>
<p>(integer, default 2) Subwords shorter than this are not emitted as tokens.</p>
</dd>
<dt class="hdlist1"><code>maxSubwordSize</code></dt>
<dd>
<p>(integer, default 15) Subwords longer than this are not emitted as tokens.</p>
</dd>
<dt class="hdlist1"><code>onlyLongestMatch</code></dt>
<dd>
<p>(true/false) If true (the default), only the longest matching subwords will generate new tokens.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<p>Assume that <code>germanwords.txt</code> contains at least the following words: <code>dumm kopf donau dampf schiff</code></p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.DictionaryCompoundWordTokenFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">dictionary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">germanwords.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"Donaudampfschiff dummkopf"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"Donaudampfschiff"(1), "dummkopf"(2),</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"Donaudampfschiff"(1), "Donau"(1), "dampf"(1), "schiff"(1), "dummkopf"(2), "dumm"(2), "kopf"(2)</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="LanguageAnalysis-UnicodeCollation">Unicode Collation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unicode Collation is a language-sensitive method of sorting text that can also be used for advanced search purposes.</p>
</div>
<div class="paragraph">
<p>Unicode Collation in Solr is fast, because all the work is done at index time.</p>
</div>
<div class="paragraph">
<p>Rather than specifying an analyzer within <code>&lt;fieldtype &#8230;&#8203; class="solr.TextField"&gt;</code>, the <code>solr.CollationField</code> and <code>solr.ICUCollationField</code> field type classes provide this functionality. <code>solr.ICUCollationField</code>, which is backed by <a href="http://site.icu-project.org">the ICU4J library</a>, provides more flexible configuration, has more locales, is significantly faster, and requires less memory and less index space, since its keys are smaller than those produced by the JDK implementation that backs <code>solr.CollationField</code>.</p>
</div>
<div class="paragraph">
<p><code>solr.ICUCollationField</code> is included in the Solr <code>analysis-extras</code> contrib - see <code>solr/contrib/analysis-extras/README.txt</code> for instructions on which jars you need to add to your <code>SOLR_HOME/lib</code> in order to use it.</p>
</div>
<div class="paragraph">
<p><code>solr.ICUCollationField</code> and <code>solr.CollationField</code> fields can be created in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Based upon a system collator associated with a Locale.</p>
</li>
<li>
<p>Based upon a tailored <code>RuleBasedCollator</code> ruleset.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_icucollationfield_arguments">ICUCollationField Arguments</h3>
<div class="paragraph">
<p>Arguments for <code>solr.ICUCollationField</code> are specified as attributes within the <code>&lt;fieldtype&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>Using a System collator:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>locale</code></dt>
<dd>
<p>(required) <a href="http://www.rfc-editor.org/rfc/rfc3066.txt">RFC 3066</a> locale ID. See <a href="http://demo.icu-project.org/icu-bin/locexp">the ICU locale explorer</a> for a list of supported locales.</p>
</dd>
<dt class="hdlist1"><code>strength</code></dt>
<dd>
<p>Valid values are <code>primary</code>, <code>secondary</code>, <code>tertiary</code>, <code>quaternary</code>, or <code>identical</code>. See <a href="http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels">Comparison Levels in ICU Collation Concepts</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>decomposition</code></dt>
<dd>
<p>Valid values are <code>no</code> or <code>canonical</code>. See <a href="http://userguide.icu-project.org/collation/concepts#TOC-Normalization">Normalization in ICU Collation Concepts</a> for more information.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Using a Tailored ruleset:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>custom</code></dt>
<dd>
<p>(required) Path to a UTF-8 text file containing rules supported by the ICU ` RuleBasedCollator `</p>
</dd>
<dt class="hdlist1"><code>strength</code></dt>
<dd>
<p>Valid values are <code>primary</code>, <code>secondary</code>, <code>tertiary</code>, <code>quaternary</code>, or <code>identical</code>. See <a href="http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels">Comparison Levels in ICU Collation Concepts</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>decomposition</code></dt>
<dd>
<p>Valid values are <code>no</code> or <code>canonical</code>. See <a href="http://userguide.icu-project.org/collation/concepts#TOC-Normalization">Normalization in ICU Collation Concepts</a> for more information.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Expert options:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>alternate</code></dt>
<dd>
<p>Valid values are <code>shifted</code> or <code>non-ignorable</code>. Can be used to ignore punctuation/whitespace.</p>
</dd>
<dt class="hdlist1"><code>caseLevel</code></dt>
<dd>
<p>(true/false) If true, in combination with <code>strength="primary"</code>, accents are ignored but case is taken into account. The default is false. See <a href="http://userguide.icu-project.org/collation/concepts#TOC-CaseLevel">CaseLevel in ICU Collation Concepts</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>caseFirst</code></dt>
<dd>
<p>Valid values are <code>lower</code> or <code>upper</code>. Useful to control which is sorted first when case is not ignored.</p>
</dd>
<dt class="hdlist1"><code>numeric</code></dt>
<dd>
<p>(true/false) If true, digits are sorted according to numeric value, e.g. foobar-9 sorts before foobar-10. The default is false.</p>
</dd>
<dt class="hdlist1"><code>variableTop</code></dt>
<dd>
<p>Single character or contraction. Controls what is variable for <code>alternate</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-SortingTextforaSpecificLanguage">Sorting Text for a Specific Language</h3>
<div class="paragraph">
<p>In this example, text is sorted according to the default German rules provided by ICU4J.</p>
</div>
<div class="paragraph">
<p>Locales are typically defined as a combination of language and country, but you can specify just the language if you want. For example, if you specify "de" as the language, you will get sorting that works well for the German language. If you specify "de" as the language and "CH" as the country, you will get German sorting specifically tailored for Switzerland.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- Define a field type for German collation --&gt;</span>
<span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">collatedGERMAN</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUCollationField</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">locale</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">de</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">strength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">primary</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
...
<span class="comment">&lt;!-- Define a field to store the German collated manufacturer names. --&gt;</span>
<span class="tag">&lt;field</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manuGERMAN</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">collatedGERMAN</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">indexed</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">stored</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">docValues</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
...
<span class="comment">&lt;!-- Copy the text to this field. We could create French, English, Spanish versions too,
     and sort differently for different users! --&gt;</span>
<span class="tag">&lt;copyField</span> <span class="attribute-name">source</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manu</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">dest</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manuGERMAN</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we defined the strength as "primary". The strength of the collation determines how strict the sort order will be, but it also depends upon the language. For example, in English, "primary" strength ignores differences in case and accents.</p>
</div>
<div class="paragraph">
<p>Another example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">polishCaseInsensitive</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUCollationField</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">locale</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pl_PL</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">strength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">secondary</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
...
<span class="tag">&lt;field</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">city</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text_general</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">indexed</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">stored</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
...
<span class="tag">&lt;field</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">city_sort</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">polishCaseInsensitive</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">indexed</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">stored</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
...
<span class="tag">&lt;copyField</span> <span class="attribute-name">source</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">city</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">dest</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">city_sort</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The type will be used for the fields where the data contains Polish text. The "secondary" strength will ignore case differences, but, unlike "primary" strength, a letter with diacritic(s) will be sorted differently from the same base letter without diacritics.</p>
</div>
<div class="paragraph">
<p>An example using the "city_sort" field to sort:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>q=*:*&amp;fl=city&amp;sort=city_sort+asc</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-SortingTextforMultipleLanguages">Sorting Text for Multiple Languages</h3>
<div class="paragraph">
<p>There are two approaches to supporting multiple languages: if there is a small list of languages you wish to support, consider defining collated fields for each language and using <code>copyField</code>. However, adding a large number of sort fields can increase disk and indexing costs. An alternative approach is to use the Unicode <code>default</code> collator.</p>
</div>
<div class="paragraph">
<p>The Unicode <code>default</code> or <code>ROOT</code> locale has rules that are designed to work well for most languages. To use the <code>default</code> locale, simply define the locale as the empty string. This Unicode default sort is still significantly more advanced than the standard Solr sort.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">collatedROOT</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUCollationField</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">locale</span>=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">strength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">primary</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-SortingTextwithCustomRules">Sorting Text with Custom Rules</h3>
<div class="paragraph">
<p>You can define your own set of sorting rules. It&#8217;s easiest to take existing rules that are close to what you want and customize them.</p>
</div>
<div class="paragraph">
<p>In the example below, we create a custom rule set for German called DIN 5007-2. This rule set treats umlauts in German differently: it treats ö as equivalent to oe, ä as equivalent to ae, and ü as equivalent to ue. For more information, see the <a href="http://icu-project.org/apiref/icu4j/com/ibm/icu/text/RuleBasedCollator.html">ICU RuleBasedCollator javadocs</a>.</p>
</div>
<div class="paragraph">
<p>This example shows how to create a custom rule set for <code>solr.ICUCollationField</code> and dump it to a file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// get the default rules for Germany</span>
<span class="comment">// these are called DIN 5007-1 sorting</span>
<span class="predefined-type">RuleBasedCollator</span> baseCollator = (<span class="predefined-type">RuleBasedCollator</span>) <span class="predefined-type">Collator</span>.getInstance(<span class="keyword">new</span> ULocale(<span class="string"><span class="delimiter">&quot;</span><span class="content">de</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">DE</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// define some tailorings, to make it DIN 5007-2 sorting.</span>
<span class="comment">// For example, this makes ö equivalent to oe</span>
<span class="predefined-type">String</span> DIN5007_2_tailorings =
    <span class="string"><span class="delimiter">&quot;</span><span class="content">&amp; ae , a</span><span class="char">\u0308</span><span class="content"> &amp; AE , A</span><span class="char">\u0308</span><span class="delimiter">&quot;</span></span>+
    <span class="string"><span class="delimiter">&quot;</span><span class="content">&amp; oe , o</span><span class="char">\u0308</span><span class="content"> &amp; OE , O</span><span class="char">\u0308</span><span class="delimiter">&quot;</span></span>+
    <span class="string"><span class="delimiter">&quot;</span><span class="content">&amp; ue , u</span><span class="char">\u0308</span><span class="content"> &amp; UE , u</span><span class="char">\u0308</span><span class="delimiter">&quot;</span></span>;

<span class="comment">// concatenate the default rules to the tailorings, and dump it to a String</span>
<span class="predefined-type">RuleBasedCollator</span> tailoredCollator = <span class="keyword">new</span> <span class="predefined-type">RuleBasedCollator</span>(baseCollator.getRules() + DIN5007_2_tailorings);
<span class="predefined-type">String</span> tailoredRules = tailoredCollator.getRules();

<span class="comment">// write these to a file, be sure to use UTF-8 encoding!!!</span>
<span class="predefined-type">FileOutputStream</span> os = <span class="keyword">new</span> <span class="predefined-type">FileOutputStream</span>(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/solr_home/conf/customRules.dat</span><span class="delimiter">&quot;</span></span>));
IOUtils.write(tailoredRules, os, <span class="string"><span class="delimiter">&quot;</span><span class="content">UTF-8</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule set can now be used for custom collation in Solr:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">---
<span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">collatedCUSTOM</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUCollationField</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">custom</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customRules.dat</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">strength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">primary</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
---</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-JDKCollation">JDK Collation</h3>
<div class="paragraph">
<p>As mentioned above, ICU Unicode Collation is better in several ways than JDK Collation, but if you cannot use ICU4J for some reason, you can use <code>solr.CollationField</code>.</p>
</div>
<div class="paragraph">
<p>The principles of JDK Collation are the same as those of ICU Collation; you just specify <code>language</code>, <code>country</code> and <code>variant</code> arguments instead of the combined <code>locale</code> argument.</p>
</div>
<div class="sect3">
<h4 id="_collationfield_arguments">CollationField Arguments</h4>
<div class="paragraph">
<p>Arguments for <code>solr.CollationField</code> are specified as attributes within the <code>&lt;fieldtype&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>Using a System collator (see <a href="http://www.oracle.com/technetwork/java/javase/javase7locales-334809.html">Oracle&#8217;s list of locales supported in Java 7</a>):</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>language</code></dt>
<dd>
<p>(required) <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO-639</a> language code</p>
</dd>
<dt class="hdlist1"><code>country</code></dt>
<dd>
<p><a href="http://www.iso.org/iso/country_codes/iso_3166_code_lists/country_names_and_code_elements.htm">ISO-3166</a> country code</p>
</dd>
<dt class="hdlist1"><code>variant</code></dt>
<dd>
<p>Vendor or browser-specific code</p>
</dd>
<dt class="hdlist1"><code>strength</code></dt>
<dd>
<p>Valid values are <code>primary</code>, <code>secondary</code>, <code>tertiary</code> or <code>identical</code>. See <a href="http://docs.oracle.com/javase/7/docs/api/java/text/Collator.html">Oracle Java 7 Collator javadocs</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>decomposition</code></dt>
<dd>
<p>Valid values are <code>no</code>, <code>canonical</code>, or <code>full</code>. See <a href="http://docs.oracle.com/javase/7/docs/api/java/text/Collator.html">Oracle Java 7 Collator javadocs</a> for more information.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Using a Tailored ruleset:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>custom</code></dt>
<dd>
<p>(required) Path to a UTF-8 text file containing rules supported by the ` JDK RuleBasedCollator `</p>
</dd>
<dt class="hdlist1"><code>strength</code></dt>
<dd>
<p>Valid values are <code>primary</code>, <code>secondary</code>, <code>tertiary</code> or <code>identical</code>. See <a href="http://docs.oracle.com/javase/7/docs/api/java/text/Collator.html">Oracle Java 7 Collator javadocs</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>decomposition</code></dt>
<dd>
<p>Valid values are <code>no</code>, <code>canonical</code>, or <code>full</code>. See <a href="http://docs.oracle.com/javase/7/docs/api/java/text/Collator.html">Oracle Java 7 Collator javadocs</a> for more information.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">Example solr.CollationField</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">collatedGERMAN</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.CollationField</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">de</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">country</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DE</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">strength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">primary</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;!-- ignore Umlauts and letter case when sorting --&gt;</span>
...
<span class="tag">&lt;field</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manuGERMAN</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">collatedGERMAN</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">indexed</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">stored</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">docValues</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
...
<span class="tag">&lt;copyField</span> <span class="attribute-name">source</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manu</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">dest</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manuGERMAN</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="LanguageAnalysis-ASCIIFoldingFilter">ASCII Folding Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if one exists. Only those characters with reasonable ASCII alternatives are converted:</p>
</div>
<div class="paragraph">
<p>This can increase recall by causing more matches. On the other hand, it can reduce precision because language-specific character differences may be lost.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ASCIIFoldingFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ASCIIFoldingFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In</dt>
<dd>
<p>"Björn Ångström"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"Björn", "Ångström"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"Bjorn", "Angstrom"</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="LanguageAnalysis-Language-SpecificFactories">Language-Specific Factories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These factories are each designed to work with specific languages.</p>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Arabic">Arabic</h3>
<div class="paragraph">
<p>Solr provides support for the <a href="http://www.mtholyoke.edu/~lballest/Pubs/arab_stem05.pdf">Light-10</a> (PDF) stemming algorithm, and Lucene includes an example stopword list.</p>
</div>
<div class="paragraph">
<p>This algorithm defines both character normalization and stemming, so these are split into two filters to provide more flexibility.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory classes</dt>
<dd>
<p><code>solr.ArabicStemFilterFactory</code>, <code>solr.ArabicNormalizationFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ArabicNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ArabicStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-BrazilianPortuguese">Brazilian Portuguese</h3>
<div class="paragraph">
<p>This is a Java filter written specifically for stemming the Brazilian dialect of the Portuguese language. It uses the Lucene class <code>org.apache.lucene.analysis.br.BrazilianStemmer</code>. Although that stemmer can be configured to use a list of protected words (which should not be stemmed), this factory does not accept any arguments to specify such a list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.BrazilianStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.BrazilianStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"praia praias"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"praia", "praias"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"pra", "pra"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Bulgarian">Bulgarian</h3>
<div class="paragraph">
<p>Solr includes a light stemmer for Bulgarian, following <a href="http://members.unine.ch/jacques.savoy/Papers/BUIR.pdf">this algorithm</a> (PDF), and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.BulgarianStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.BulgarianStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Catalan">Catalan</h3>
<div class="paragraph">
<p>Solr can stem Catalan using the Snowball Porter Stemmer with an argument of <code>language="Catalan"</code>. Solr includes a set of contractions for Catalan, which can be stripped using <code>solr.ElisionFilterFactory</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SnowballPorterFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>language</code></dt>
<dd>
<p>(required) stemmer language, "Catalan" in this case</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ElisionFilterFactory</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">articles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/contractions_ca.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Catalan</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"llengües llengua"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"llengües"(1) "llengua"(2),</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"llengu"(1), "llengu"(2)</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Chinese">Chinese</h3>
<div class="sect3">
<h4 id="LanguageAnalysis-ChineseTokenizer">Chinese Tokenizer</h4>
<div class="paragraph">
<p>The Chinese Tokenizer is deprecated as of Solr 3.4. Use the <a href="Tokenizers.html#Tokenizers-StandardTokenizer"><code>solr.StandardTokenizerFactory</code></a> instead.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ChineseTokenizerFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ChineseTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-ChineseFilterFactory">Chinese Filter Factory</h4>
<div class="paragraph">
<p>The Chinese Filter Factory is deprecated as of Solr 3.4. Use the <a href="Filter-Descriptions.html#FilterDescriptions-StopFilter"><code>solr.StopFilterFactory</code></a> instead.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ChineseFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ChineseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-SimplifiedChinese">Simplified Chinese</h4>
<div class="paragraph">
<p>For Simplified Chinese, Solr provides support for Chinese sentence and word segmentation with the <code>solr.HMMChineseTokenizerFactory</code> in the <code>analysis-extras</code> contrib module. This component includes a large dictionary and segments Chinese text into words with the Hidden Markov Model. To use this filter, see <code>solr/contrib/analysis-extras/README.txt</code> for instructions on which jars you need to add to your <code>solr_home/lib</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.HMMChineseTokenizerFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Examples</dt>
<dd>
<div class="paragraph">
<p>To use the default setup with fallback to English Porter stemmer for English words, use:</p>
</div>
<div class="paragraph">
<p><code>&lt;analyzer class="org.apache.lucene.analysis.cn.smart.SmartChineseAnalyzer"/&gt;</code></p>
</div>
<div class="paragraph">
<p>Or to configure your own analysis setup, use the <code>solr.HMMChineseTokenizerFactory</code> along with your custom filter setup.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.HMMChineseTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StopFilterFactory</span>
          <span class="content">words=</span><span class="delimiter">&quot;</span></span><span class="attribute-name">org</span><span class="error">/</span><span class="attribute-name">apache</span><span class="error">/</span><span class="attribute-name">lucene</span><span class="error">/</span><span class="attribute-name">analysis</span><span class="error">/</span><span class="attribute-name">cn</span><span class="error">/</span><span class="attribute-name">smart</span><span class="error">/</span><span class="attribute-name">stopwords.txt</span><span class="error">&quot;</span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PorterStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-CJK">CJK</h3>
<div class="paragraph">
<p>This tokenizer breaks Chinese, Japanese and Korean language text into tokens. These are not whitespace delimited languages. The tokens generated by this tokenizer are "doubles", overlapping pairs of CJK characters found in the field text.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.CJKTokenizerFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.CJKTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Czech">Czech</h3>
<div class="paragraph">
<p>Solr includes a light stemmer for Czech, following <a href="https://dl.acm.org/citation.cfm?id=1598600">this algorithm</a>, and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.CzechStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.CzechStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"prezidenští, prezidenta, prezidentského"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"prezidenští", "prezidenta", "prezidentského"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"preziden", "preziden", "preziden"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Danish">Danish</h3>
<div class="paragraph">
<p>Solr can stem Danish using the Snowball Porter Stemmer with an argument of <code>language="Danish"</code>.</p>
</div>
<div class="paragraph">
<p>Also relevant are the <a href="#LanguageAnalysis-Scandinavian">Scandinavian normalization filters</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SnowballPorterFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>language</code></dt>
<dd>
<p>(required) stemmer language, "Danish" in this case</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Danish</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"undersøg undersøgelse"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"undersøg"(1) "undersøgelse"(2),</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"undersøg"(1), "undersøg"(2)</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Dutch">Dutch</h3>
<div class="paragraph">
<p>Solr can stem Dutch using the Snowball Porter Stemmer with an argument of <code>language="Dutch"</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SnowballPorterFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>language</code></dt>
<dd>
<p>(required) stemmer language, "Dutch" in this case</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Dutch</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"kanaal kanalen"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"kanaal", "kanalen"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"kanal", "kanal"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Finnish">Finnish</h3>
<div class="paragraph">
<p>Solr includes support for stemming Finnish, and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.FinnishLightStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre>&lt;analyzer type="index"&gt;
  &lt;tokenizer class="solr.StandardTokenizerFactory"/&gt;
  &lt;filter class="solr.FinnishLightStemFilterFactory"/&gt;
&lt;/analyzer&gt;</pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"kala kalat"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"kala", "kalat"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"kala", "kala"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-French">French</h3>
<div class="sect3">
<h4 id="LanguageAnalysis-ElisionFilter">Elision Filter</h4>
<div class="paragraph">
<p>Removes article elisions from a token stream. This filter can be useful for languages such as French, Catalan, Italian, and Irish.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ElisionFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>articles</code></dt>
<dd>
<p>The pathname of a file that contains a list of articles, one per line, to be stripped. Articles are words such as "le", which are commonly abbreviated, such as in <em>l&#8217;avion</em> (the plane). This file should include the abbreviated form, which precedes the apostrophe. In this case, simply "<em>l</em>". If no <code>articles</code> attribute is specified, a default set of French articles is used.</p>
</dd>
<dt class="hdlist1"><code>ignoreCase</code></dt>
<dd>
<p>(boolean) If true, the filter ignores the case of words when comparing them to the common word file. Defaults to <code>false</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ElisionFilterFactory</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">articles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/contractions_fr.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"L&#8217;histoire d&#8217;art"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"L&#8217;histoire", "d&#8217;art"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"histoire", "art"</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-FrenchLightStemFilter">French Light Stem Filter</h4>
<div class="paragraph">
<p>Solr includes three stemmers for French: one in the <code>solr.SnowballPorterFilterFactory</code>, a lighter stemmer called <code>solr.FrenchLightStemFilterFactory</code>, and an even less aggressive stemmer called <code>solr.FrenchMinimalStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory classes</dt>
<dd>
<p><code>solr.FrenchLightStemFilterFactory</code>, <code>solr.FrenchMinimalStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Examples</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ElisionFilterFactory</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">articles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/contractions_fr.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.FrenchLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ElisionFilterFactory</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">articles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/contractions_fr.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.FrenchMinimalStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"le chat, les chats"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"le", "chat", "les", "chats"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"le", "chat", "le", "chat"</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Galician">Galician</h3>
<div class="paragraph">
<p>Solr includes a stemmer for Galician following <a href="http://bvg.udc.es/recursos_lingua/stemming.jsp">this algorithm</a>, and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.GalicianStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.GalicianStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"felizmente Luzes"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"felizmente", "luzes"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"feliz", "luz"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-German">German</h3>
<div class="paragraph">
<p>Solr includes four stemmers for German:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>one in the <code>solr.SnowballPorterFilterFactory language="German"</code>,</p>
</li>
<li>
<p>a stemmer called <code>solr.GermanStemFilterFactory</code>,</p>
</li>
<li>
<p>a lighter stemmer called <code>solr.GermanLightStemFilterFactory</code>,</p>
</li>
<li>
<p>and an even less aggressive stemmer called <code>solr.GermanMinimalStemFilterFactory</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Lucene includes an example stopword list.</p>
</div>
<div class="paragraph">
<p><strong>Factory classes:::</strong> <code>solr.GermanStemFilterFactory</code>, <code>solr.LightGermanStemFilterFactory</code>, <code>solr.MinimalGermanStemFilterFactory</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Examples</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory </span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.GermanStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.GermanLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory </span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.GermanMinimalStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"haus häuser"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"haus", "häuser"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"haus", "haus"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Greek">Greek</h3>
<div class="paragraph">
<p>This filter converts uppercase letters in the Greek character set to the equivalent lowercase character.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.GreekLowerCaseFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Use of custom charsets is not supported as of Solr 3.1. If you need to index text in these encodings, please use Java&#8217;s character set conversion facilities (<code>InputStreamReader</code>, and so on.) during I/O, so that Lucene can analyze this text as Unicode instead.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.GreekLowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Hindi">Hindi</h3>
<div class="paragraph">
<p>Solr includes support for stemming Hindi following <a href="http://computing.open.ac.uk/Sites/EACLSouthAsia/Papers/p6-Ramanathan.pdf">this algorithm</a> (PDF), support for common spelling differences through the <code>solr.HindiNormalizationFilterFactory</code>, support for encoding differences through the <code>solr.IndicNormalizationFilterFactory</code> following <a href="http://ldc.upenn.edu/myl/IndianScriptsUnicode.html">this algorithm</a>, and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory classes</dt>
<dd>
<p><code>solr.IndicNormalizationFilterFactory</code>, <code>solr.HindiNormalizationFilterFactory</code>, <code>solr.HindiStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.IndicNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.HindiNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.HindiStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Indonesian">Indonesian</h3>
<div class="paragraph">
<p>Solr includes support for stemming Indonesian (Bahasa Indonesia) following <a href="http://www.illc.uva.nl/Publications/ResearchReports/MoL-2003-02.text.pdf">this algorithm</a> (PDF), and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.IndonesianStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.IndonesianStemFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">stemDerivational</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"sebagai sebagainya"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"sebagai", "sebagainya"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"bagai", "bagai"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Italian">Italian</h3>
<div class="paragraph">
<p>Solr includes two stemmers for Italian: one in the <code>solr.SnowballPorterFilterFactory language="Italian"</code>, and a lighter stemmer called <code>solr.ItalianLightStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ItalianStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ElisionFilterFactory</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">articles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/contractions_it.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ItalianLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"propaga propagare propagamento"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"propaga", "propagare", "propagamento"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"propag", "propag", "propag"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Irish">Irish</h3>
<div class="paragraph">
<p>Solr can stem Irish using the Snowball Porter Stemmer with an argument of <code>language="Irish"</code>. Solr includes <code>solr.IrishLowerCaseFilterFactory</code>, which can handle Irish-specific constructs. Solr also includes a set of contractions for Irish which can be stripped using <code>solr.ElisionFilterFactory</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SnowballPorterFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>language</code></dt>
<dd>
<p>(required) stemmer language, "Irish" in this case</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ElisionFilterFactory</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">articles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/contractions_ga.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.IrishLowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Irish</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"siopadóireacht síceapatacha b&#8217;fhearr m&#8217;athair"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"siopadóireacht", "síceapatacha", "b&#8217;fhearr", "m&#8217;athair"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"siopadóir", "síceapaite", "fearr", "athair"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Japanese">Japanese</h3>
<div class="paragraph">
<p>Solr includes support for analyzing Japanese, via the Lucene Kuromoji morphological analyzer, which includes several analysis components - more details on each below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JapaneseIterationMarkCharFilter</code> normalizes Japanese horizontal iteration marks (odoriji) to their expanded form.</p>
</li>
<li>
<p><code>JapaneseTokenizer</code> tokenizes Japanese using morphological analysis, and annotates each term with part-of-speech, base form (a.k.a. lemma), reading and pronunciation.</p>
</li>
<li>
<p><code>JapaneseBaseFormFilter</code> replaces original terms with their base forms (a.k.a. lemmas).</p>
</li>
<li>
<p><code>JapanesePartOfSpeechStopFilter</code> removes terms that have one of the configured parts-of-speech.</p>
</li>
<li>
<p><code>JapaneseKatakanaStemFilter</code> normalizes common katakana spelling variations ending in a long sound character (U+30FC) by removing the long sound character.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also useful for Japanese analysis, from lucene-analyzers-common:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CJKWidthFilter</code> folds fullwidth ASCII variants into the equivalent Basic Latin forms, and folds halfwidth Katakana variants into their equivalent fullwidth forms.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-JapaneseIterationMarkCharFilter">Japanese Iteration Mark CharFilter</h4>
<div class="paragraph">
<p>Normalizes horizontal Japanese iteration marks (odoriji) to their expanded form. Vertical iteration marks are not supported.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>JapaneseIterationMarkCharFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p><code>normalizeKanji</code>: set to <code>false</code> to not normalize kanji iteration marks (default is <code>true</code>)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>` normalizeKana`: set to <code>false</code> to not normalize kana iteration marks (default is <code>true</code>)</p>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-JapaneseTokenizer">Japanese Tokenizer</h4>
<div class="paragraph">
<p>Tokenizer for Japanese that uses morphological analysis, and annotates each term with part-of-speech, base form (a.k.a. lemma), reading and pronunciation.</p>
</div>
<div class="paragraph">
<p><code>JapaneseTokenizer</code> has a <code>search</code> mode (the default) that does segmentation useful for search: a heuristic is used to segment compound terms into their constituent parts while also keeping the original compound terms as synonyms.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.JapaneseTokenizerFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mode</code></dt>
<dd>
<p>Use <code>search</code> mode to get a noun-decompounding effect useful for search. <code>search</code> mode improves segmentation for search at the expense of part-of-speech accuracy. Valid values for <code>mode</code> are:</p>
<div class="ulist">
<ul>
<li>
<p><code>normal</code>: default segmentation</p>
</li>
<li>
<p><code>search</code>: segmentation useful for search (extra compound splitting)</p>
</li>
<li>
<p><code>extended</code>: search mode plus unigramming of unknown words (experimental)</p>
<div class="paragraph">
<p>For some applications it might be good to use <code>search</code> mode for indexing and <code>normal</code> mode for queries to increase precision and prevent parts of compounds from being matched and highlighted.</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>userDictionary</code></dt>
<dd>
<p>filename for a user dictionary, which allows overriding the statistical model with your own entries for segmentation, part-of-speech tags and readings without a need to specify weights. See <code>lang/userdict_ja.txt</code> for a sample user dictionary file.</p>
</dd>
<dt class="hdlist1"><code>userDictionaryEncoding</code></dt>
<dd>
<p>user dictionary encoding (default is UTF-8)</p>
</dd>
<dt class="hdlist1"><code>discardPunctuation</code></dt>
<dd>
<p>set to <code>false</code> to keep punctuation, <code>true</code> to discard (the default)</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-JapaneseBaseFormFilter">Japanese Base Form Filter</h4>
<div class="paragraph">
<p>Replaces original terms' text with the corresponding base form (lemma). (<code>JapaneseTokenizer</code> annotates each term with its base form.)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>JapaneseBaseFormFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-JapanesePartOfSpeechStopFilter">Japanese Part Of Speech Stop Filter</h4>
<div class="paragraph">
<p>Removes terms with one of the configured parts-of-speech. <code>JapaneseTokenizer</code> annotates terms with parts-of-speech.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>JapanesePartOfSpeechStopFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>tags</code></dt>
<dd>
<p>filename for a list of parts-of-speech for which to remove terms; see <code>conf/lang/stoptags_ja.txt</code> in the <code>sample_techproducts_config</code> <a href="Config-Sets.html">config set</a> for an example.</p>
</dd>
<dt class="hdlist1"><code>enablePositionIncrements</code></dt>
<dd>
<p>if <code>luceneMatchVersion</code> is <code>4.3</code> or earlier and <code>enablePositionIncrements="false"</code>, no position holes will be left by this filter when it removes tokens. <strong>This argument is invalid if <code>luceneMatchVersion</code> is <code>5.0</code> or later.</strong></p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-JapaneseKatakanaStemFilter">Japanese Katakana Stem Filter</h4>
<div class="paragraph">
<p>Normalizes common katakana spelling variations ending in a long sound character (U+30FC) by removing the long sound character.</p>
</div>
<div class="paragraph">
<p><code>CJKWidthFilterFactory</code> should be specified prior to this filter to normalize half-width katakana to full-width.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>JapaneseKatakanaStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>minimumLength</code></dt>
<dd>
<p>terms below this length will not be stemmed. Default is 4, value must be 2 or more.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-CJKWidthFilter">CJK Width Filter</h4>
<div class="paragraph">
<p>Folds fullwidth ASCII variants into the equivalent Basic Latin forms, and folds halfwidth Katakana variants into their equivalent fullwidth forms.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>CJKWidthFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text_ja</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">positionIncrementGap</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">autoGeneratePhraseQueries</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="comment">&lt;!-- Uncomment if you need to handle iteration marks: --&gt;</span>
    <span class="comment">&lt;!-- &lt;charFilter class=&quot;solr.JapaneseIterationMarkCharFilterFactory&quot; /&gt; --&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.JapaneseTokenizerFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">userDictionary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/userdict_ja.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.JapaneseBaseFormFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.JapanesePartOfSpeechStopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tags</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/stoptags_ja.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.CJKWidthFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/stopwords_ja.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.JapaneseKatakanaStemFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">minimumLength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Hebrew">Hebrew, Lao, Myanmar, Khmer</h3>
<div class="paragraph">
<p>Lucene provides support, in addition to UAX#29 word break rules, for Hebrew&#8217;s use of the double and single quote characters, and for segmenting Lao, Myanmar, and Khmer into syllables with the <code>solr.ICUTokenizerFactory</code> in the <code>analysis-extras</code> contrib module. To use this tokenizer, see <code>solr/contrib/analysis-extras/README.txt for</code> instructions on which jars you need to add to your <code>solr_home/lib</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="Tokenizers.html#Tokenizers-ICUTokenizer">the ICUTokenizer</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Latvian">Latvian</h3>
<div class="paragraph">
<p>Solr includes support for stemming Latvian, and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.LatvianStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text_lvstem</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">positionIncrementGap</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LatvianStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"tirgiem tirgus"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"tirgiem", "tirgus"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"tirg", "tirg"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Norwegian">Norwegian</h3>
<div class="paragraph">
<p>Solr includes two classes for stemming Norwegian, <code>NorwegianLightStemFilterFactory</code> and <code>NorwegianMinimalStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="paragraph">
<p>Another option is to use the Snowball Porter Stemmer with an argument of language="Norwegian".</p>
</div>
<div class="paragraph">
<p>Also relevant are the <a href="#LanguageAnalysis-Scandinavian">Scandinavian normalization filters</a>.</p>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-NorwegianLightStemmer">Norwegian Light Stemmer</h4>
<div class="paragraph">
<p>The <code>NorwegianLightStemFilterFactory</code> requires a "two-pass" sort for the -dom and -het endings. This means that in the first pass the word "kristendom" is stemmed to "kristen", and then all the general rules apply so it will be further stemmed to "krist". The effect of this is that "kristen," "kristendom," "kristendommen," and "kristendommens" will all be stemmed to "krist."</p>
</div>
<div class="paragraph">
<p>The second pass is to pick up -dom and -het endings. Consider this example:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>One pass</strong></th>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top"><strong>Two passes</strong></th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Before</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>After</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Before</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>After</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forleg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forleg</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegenhet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegenhet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forleg</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegenheten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegenheten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forleg</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegenhetens</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forlegenhetens</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">forleg</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantethet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantethet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantetheten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkantetheten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firkant</p></td>
</tr>
</tbody>
</table>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.NorwegianLightStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>variant</code></dt>
<dd>
<p>Choose the Norwegian language variant to use. Valid values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>nb:</code> Bokmål (default)</p>
</li>
<li>
<p><code>nn:</code> Nynorsk</p>
</li>
<li>
<p><code>no:</code> both</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text_no</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">positionIncrementGap</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/stopwords_no.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">format</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">snowball</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.NorwegianLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"Forelskelsen"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"forelskelsen"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"forelske"</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-NorwegianMinimalStemmer">Norwegian Minimal Stemmer</h4>
<div class="paragraph">
<p>The <code>NorwegianMinimalStemFilterFactory</code> stems plural forms of Norwegian nouns only.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.NorwegianMinimalStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>variant</code></dt>
<dd>
<p>Choose the Norwegian language variant to use. Valid values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>nb:</code> Bokmål (default)</p>
</li>
<li>
<p><code>nn:</code> Nynorsk</p>
</li>
<li>
<p><code>no:</code> both</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text_no</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">positionIncrementGap</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lang/stopwords_no.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">format</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">snowball</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.NorwegianMinimalStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"Bilens"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"bilens"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"bil"</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Persian">Persian</h3>
<div class="sect3">
<h4 id="LanguageAnalysis-PersianFilterFactories">Persian Filter Factories</h4>
<div class="paragraph">
<p>Solr includes support for normalizing Persian, and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.PersianNormalizationFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ArabicNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PersianNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Polish">Polish</h3>
<div class="paragraph">
<p>Solr provides support for Polish stemming with the <code>solr.StempelPolishStemFilterFactory</code>, and <code>solr.MorphologikFilterFactory</code> for lemmatization, in the <code>contrib/analysis-extras</code> module. The <code>solr.StempelPolishStemFilterFactory</code> component includes an algorithmic stemmer with tables for Polish. To use either of these filters, see <code>solr/contrib/analysis-extras/README.txt</code> for instructions on which jars you need to add to your <code>solr_home/lib</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.StempelPolishStemFilterFactory</code> and <code>solr.MorfologikFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StempelPolishStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.MorfologikFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">dictionary-resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>""studenta studenci"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"studenta", "studenci"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"student", "student"</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>More information about the Stempel stemmer is available in <a href="http://lucene.apache.org/core/5_3_0/analyzers-stempel/index.html">the Lucene javadocs</a>.</p>
</div>
<div class="paragraph">
<p>The Morfologik <code>dictionary-resource</code> param value is a constant specifying which dictionary to choose. The dictionary resource must be named <code>morfologik/dictionaries/{dictionaryResource}.dict</code> and have an associated <code>.info</code> metadata file. See <a href="http://morfologik.blogspot.com/">the Morfologik project</a> for details.</p>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Portuguese">Portuguese</h3>
<div class="paragraph">
<p>Solr includes four stemmers for Portuguese: one in the <code>solr.SnowballPorterFilterFactory</code>, an alternative stemmer called <code>solr.PortugueseStemFilterFactory</code>, a lighter stemmer called <code>solr.PortugueseLightStemFilterFactory</code>, and an even less aggressive stemmer called <code>solr.PortugueseMinimalStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory classes</dt>
<dd>
<p><code>solr.PortugueseStemFilterFactory</code>, <code>solr.PortugueseLightStemFilterFactory</code>, <code>solr.PortugueseMinimalStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Examples</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PortugueseStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PortugueseLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PortugueseMinimalStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"praia praias"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"praia", "praias"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"pra", "pra"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Romanian">Romanian</h3>
<div class="paragraph">
<p>Solr can stem Romanian using the Snowball Porter Stemmer with an argument of <code>language="Romanian"</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SnowballPorterFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>language</code></dt>
<dd>
<p>(required) stemmer language, "Romanian" in this case</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Romanian</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Russian">Russian</h3>
<div class="sect3">
<h4 id="LanguageAnalysis-RussianStemFilter">Russian Stem Filter</h4>
<div class="paragraph">
<p>Solr includes two stemmers for Russian: one in the <code>solr.SnowballPorterFilterFactory language="Russian"</code>, and a lighter stemmer called <code>solr.RussianLightStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.RussianLightStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Use of custom charsets is no longer supported as of Solr 3.4. If you need to index text in these encodings, please use Java&#8217;s character set conversion facilities (<code>InputStreamReader</code>, and so on.) during I/O, so that Lucene can analyze this text as Unicode instead.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.RussianLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Scandinavian">Scandinavian</h3>
<div class="paragraph">
<p>Scandinavian is a language group spanning three languages <a href="#LanguageAnalysis-Norwegian">Norwegian</a>, <a href="#LanguageAnalysis-Swed">Swedish</a> and <a href="#LanguageAnalysis-Danish">Danish</a> which are very similar.</p>
</div>
<div class="paragraph">
<p>Swedish å,ä,ö are in fact the same letters as Norwegian and Danish å,æ,ø and thus interchangeable when used between these languages. They are however folded differently when people type them on a keyboard lacking these characters.</p>
</div>
<div class="paragraph">
<p>In that situation almost all Swedish people use a, a, o instead of å, ä, ö. Norwegians and Danes on the other hand usually type aa, ae and oe instead of å, æ and ø. Some do however use a, a, o, oo, ao and sometimes permutations of everything above.</p>
</div>
<div class="paragraph">
<p>There are two filters for helping with normalization between Scandinavian languages: one is <code>solr.ScandinavianNormalizationFilterFactory</code> trying to preserve the special characters (æäöå) and another <code>solr.ScandinavianFoldingFilterFactory</code> which folds these to the more broad ø/ö&#8594;o etc.</p>
</div>
<div class="paragraph">
<p>See also each language section for other relevant filters.</p>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-ScandinavianNormalizationFilter">Scandinavian Normalization Filter</h4>
<div class="paragraph">
<p>This filter normalize use of the interchangeable Scandinavian characters æÆäÄöÖøØ and folded variants (aa, ao, ae, oe and oo) by transforming them to åÅæÆøØ.</p>
</div>
<div class="paragraph">
<p>It&#8217;s a semantically less destructive solution than <code>ScandinavianFoldingFilter</code>, most useful when a person with a Norwegian or Danish keyboard queries a Swedish index and vice versa. This filter does <strong>not</strong> perform the common Swedish folds of å and ä to a nor ö to o.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ScandinavianNormalizationFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ScandinavianNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"blåbærsyltetøj blåbärsyltetöj blaabaarsyltetoej blabarsyltetoj"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"blåbærsyltetøj", "blåbärsyltetöj", "blaabaersyltetoej", "blabarsyltetoj"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"blåbærsyltetøj", "blåbærsyltetøj", "blåbærsyltetøj", "blabarsyltetoj"</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="LanguageAnalysis-ScandinavianFoldingFilter">Scandinavian Folding Filter</h4>
<div class="paragraph">
<p>This filter folds Scandinavian characters åÅäæÄÆ&#8594;a and öÖøØ&#8594;o. It also discriminate against use of double vowels aa, ae, ao, oe and oo, leaving just the first one.</p>
</div>
<div class="paragraph">
<p>It&#8217;s is a semantically more destructive solution than <code>ScandinavianNormalizationFilter</code>, but can in addition help with matching raksmorgas as räksmörgås.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ScandinavianFoldingFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ScandinavianFoldingFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"blåbærsyltetøj blåbärsyltetöj blaabaarsyltetoej blabarsyltetoj"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"blåbærsyltetøj", "blåbärsyltetöj", "blaabaersyltetoej", "blabarsyltetoj"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"blabarsyltetoj", "blabarsyltetoj", "blabarsyltetoj", "blabarsyltetoj"</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Serbian">Serbian</h3>
<div class="sect3">
<h4 id="LanguageAnalysis-SerbianNormalizationFilter">Serbian Normalization Filter</h4>
<div class="paragraph">
<p>Solr includes a filter that normalizes Serbian Cyrillic and Latin characters to "bald" Latin. Cyrillic characters are first converted to Latin; then, Latin characters have their diacritics removed, with the exception of &#8220;đ&#8221; which is converted to &#8220;dj&#8221;. Note that this filter expects lowercased input.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SerbianNormalizationFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SerbianNormalizationFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"Đura (Ђура) српски"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"đura" "ђура" "српски"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"djura", "djura", "srpski"</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Spanish">Spanish</h3>
<div class="paragraph">
<p>Solr includes two stemmers for Spanish: one in the <code>solr.SnowballPorterFilterFactory language="Spanish"</code>, and a lighter stemmer called <code>solr.SpanishLightStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SpanishStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SpanishLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"torear toreara torearlo"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"torear", "toreara", "torearlo"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"tor", "tor", "tor"</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Swedish">Swedish</h3>
<div class="sect3">
<h4 id="LanguageAnalysis-SwedishStemFilter">Swedish Stem Filter</h4>
<div class="paragraph">
<p>Solr includes two stemmers for Swedish: one in the <code>solr.SnowballPorterFilterFactory language="Swedish"</code>, and a lighter stemmer called <code>solr.SwedishLightStemFilterFactory</code>. Lucene includes an example stopword list.</p>
</div>
<div class="paragraph">
<p>Also relevant are the <a href="#LanguageAnalysis-Scandinavian">Scandinavian normalization filters</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.SwedishStemFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SwedishLightStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">In</dt>
<dd>
<p>"kloke klokhet klokheten"</p>
</dd>
<dt class="hdlist1">Tokenizer to Filter</dt>
<dd>
<p>"kloke", "klokhet", "klokheten"</p>
</dd>
<dt class="hdlist1">Out</dt>
<dd>
<p>"klok", "klok", "klok"</p>
</dd>
</dl>
</div>
<div id="LanguageAnalysis-Thai" class="paragraph">
<p>Thai</p>
</div>
<div class="paragraph">
<p>This filter converts sequences of Thai characters into individual Thai words. Unlike European languages, Thai does not use whitespace to delimit words.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.ThaiTokenizerFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ThaiTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="LanguageAnalysis-Turkish">Turkish</h3>
<div class="paragraph">
<p>Solr includes support for stemming Turkish through the <code>solr.SnowballPorterFilterFactory</code>; support for case-insensitive search through the <code>solr.TurkishLowerCaseFilterFactory</code>; support for stripping apostrophes and following suffixes through <code>solr.ApostropheFilterFactory</code> (see <a href="http://www.ipcsit.com/vol57/015-ICNI2012-M021.pdf">Role of Apostrophes in Turkish Information Retrieval</a>); support for a form of stemming that truncating tokens at a configurable maximum length through the solr.TruncateTokenFilterFactory (see <a href="http://www.users.muohio.edu/canf/papers/JASIST2008offPrint.pdf">Information Retrieval on Turkish Texts</a>); and Lucene includes an example stopword list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Factory class</dt>
<dd>
<p><code>solr.TurkishLowerCaseFilterFactory</code></p>
</dd>
<dt class="hdlist1">Arguments</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Example</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ApostropheFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TurkishLowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Turkish</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example, illustrating diacritics-insensitive search:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ApostropheFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TurkishLowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ASCIIFoldingFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">preserveOriginal</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.KeywordRepeatFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TruncateTokenFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">prefixLength</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">5</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.RemoveDuplicatesTokenFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div></p>

	<hr />

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2014 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.4.0</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>
    
  </body>
</html>