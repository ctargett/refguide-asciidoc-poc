<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Filter Descriptions</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">
    <link href="css/ref-guide.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="">Solr</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Sections <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="About-Filters.html">About Filters</a></li>
                <li><a href="#">Another action</a></li>
                <li><a href="#">Something else here</a></li>
                <li class="divider"></li>
                <li class="dropdown-header">Nav header</li>
                <li><a href="#">Separated link</a></li>
                <li><a href="#">One more separated link</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

	<div class="page-header">
		<h1>Filter Descriptions</h1>
	</div>

	<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>You configure each filter with a <code>&lt;filter&gt;</code> element in <code>schema.xml</code> as a child of <code>&lt;analyzer&gt;</code>, following the <code>&lt;tokenizer&gt;</code> element. Filter definitions should follow a tokenizer or another filter definition because they take a <code>TokenStream</code> as input. For example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>...
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The class attribute names a factory class that will instantiate a filter object as needed. Filter factory classes must implement the <code>org.apache.solr.analysis.TokenFilterFactory</code> interface. Like tokenizers, filters are also instances of TokenStream and thus are producers of tokens. Unlike tokenizers, filters also consume tokens from a TokenStream. This allows you to mix and match filters, in any order you prefer, downstream of a tokenizer.</p>
</div>
<div class="paragraph">
<p>Arguments may be passed to tokenizer factories to modify their behavior by setting attributes on the <code>&lt;filter&gt;</code> element. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;fieldType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">semicolonDelimited</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TextField</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PatternTokenizerFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pattern</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">; </span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LengthFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">min</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">max</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/analyzer&gt;</span>
<span class="tag">&lt;/fieldType&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following sections describe the filter factories that are included in this release of Solr.</p>
</div>
<div class="paragraph">
<p>Filters discussed in this section:</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">In This Section</div>
<ul class="sectlevel1">
<li><a href="#_ascii_folding_filter">ASCII Folding Filter</a></li>
<li><a href="#_beider_morse_filter">Beider-Morse Filter</a></li>
<li><a href="#_classic_filter">Classic Filter</a></li>
<li><a href="#_common_grams_filter">Common Grams Filter</a></li>
<li><a href="#_collation_key_filter">Collation Key Filter</a></li>
<li><a href="#_daitch_mokotoff_soundex_filter">Daitch-Mokotoff Soundex Filter</a></li>
<li><a href="#_double_metaphone_filter">Double Metaphone Filter</a></li>
<li><a href="#_edge_n_gram_filter">Edge N-Gram Filter</a></li>
<li><a href="#_english_minimal_stem_filter">English Minimal Stem Filter</a></li>
<li><a href="#_hunspell_stem_filter">Hunspell Stem Filter</a></li>
<li><a href="#_hyphenated_words_filter">Hyphenated Words Filter</a></li>
<li><a href="#_icu_folding_filter">ICU Folding Filter</a></li>
<li><a href="#_icu_normalizer_2_filter">ICU Normalizer 2 Filter</a></li>
<li><a href="#_icu_transform_filter">ICU Transform Filter</a></li>
<li><a href="#_keep_words_filter">Keep Words Filter</a></li>
<li><a href="#_kstem_filter">KStem Filter</a></li>
<li><a href="#_length_filter">Length Filter</a></li>
<li><a href="#_lower_case_filter">Lower Case Filter</a></li>
<li><a href="#_managed_stop_filter">Managed Stop Filter</a></li>
<li><a href="#_managed_synonym_filter">Managed Synonym Filter</a></li>
<li><a href="#_n_gram_filter">N-Gram Filter</a></li>
<li><a href="#_numeric_payload_token_filter">Numeric Payload Token Filter</a></li>
<li><a href="#_pattern_replace_filter">Pattern Replace Filter</a></li>
<li><a href="#_phonetic_filter">Phonetic Filter</a></li>
<li><a href="#_porter_stem_filter">Porter Stem Filter</a></li>
<li><a href="#_remove_duplicates_token_filter">Remove Duplicates Token Filter</a></li>
<li><a href="#_reversed_wildcard_filter">Reversed Wildcard Filter</a></li>
<li><a href="#_shingle_filter">Shingle Filter</a></li>
<li><a href="#_snowball_porter_stemmer_filter">Snowball Porter Stemmer Filter</a></li>
<li><a href="#_standard_filter">Standard Filter</a></li>
<li><a href="#_stop_filter">Stop Filter</a></li>
<li><a href="#_suggest_stop_filter">Suggest Stop Filter</a></li>
<li><a href="#_synonym_filter">Synonym Filter</a></li>
<li><a href="#_token_offset_payload_filter">Token Offset Payload Filter</a></li>
<li><a href="#_trim_filter">Trim Filter</a></li>
<li><a href="#_type_as_payload_filter">Type As Payload Filter</a></li>
<li><a href="#_type_token_filter">Type Token Filter</a></li>
<li><a href="#_word_delimiter_filter">Word Delimiter Filter</a></li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ascii_folding_filter">ASCII Folding Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter converts alphabetic, numeric, and symbolic Unicode characters which are not in the Basic Latin Unicode block (the first 127 ASCII characters) to their ASCII equivalents, if one exists. This filter converts characters from the following Unicode blocks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U0080.pdf">C1 Controls and Latin-1 Supplement</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U0100.pdf">Latin Extended-A</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U0180.pdf">Latin Extended-B</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U1E00.pdf">Latin Extended Additional</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U2C60.pdf">Latin Extended-C</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/UA720.pdf">Latin Extended-D</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U0250.pdf">IPA Extensions</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U1D00.pdf">Phonetic Extensions</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U1D80.pdf">Phonetic Extensions Supplement</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U2000.pdf">General Punctuation</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U2070.pdf">Superscripts and Subscripts</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U2460.pdf">Enclosed Alphanumerics</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U2700.pdf">Dingbats</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/U2E00.pdf">Supplemental Punctuation</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/UFB00.pdf">Alphabetic Presentation Forms</a> (PDF)</p>
</li>
<li>
<p><a href="http://www.unicode.org/charts/PDF/UFF00.pdf">Halfwidth and Fullwidth Forms</a> (PDF)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ASCIIFoldingFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ASCIIFoldingFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "รก" (Unicode character 00E1)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "a" (ASCII character 97)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_beider_morse_filter">Beider-Morse Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Implements the Beider-Morse Phonetic Matching (BMPM) algorithm, which allows identification of similar names, even if they are spelled differently or in different languages. More information about how this works is available in the section on <a href="#Phonetic-Matching.adoc">Phonetic Matching</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
BeiderMorseFilter changed its behavior in Solr 5.0 (version 3.04 of the BMPM algorithm is implemented, while previous Solr versions implemented BMPM version 3.00 - see <a href="http://stevemorse.org/phoneticinfo.htm" class="bare">http://stevemorse.org/phoneticinfo.htm</a>), so any index built using this filter with earlier versions of Solr will need to be rebuilt.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.BeiderMorseFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>nameType</code>: Types of names. Valid values are GENERIC, ASHKENAZI, or SEPHARDIC. If not processing Ashkenazi or Sephardic names, use GENERIC.</p>
</div>
<div class="paragraph">
<p><code>ruleType</code>: Types of rules to apply. Valid values are APPROX or EXACT.</p>
</div>
<div class="paragraph">
<p><code>concat</code>: Defines if multiple possible matches should be combined with a pipe ("|").</p>
</div>
<div class="paragraph">
<p><code>languageSet</code>: The language set to use. The value "auto" will allow the Filter to identify the language, or a comma-separated list can be supplied.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.BeiderMorseFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">nameType</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">GENERIC</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ruleType</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">APPROX</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">concat</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">languageSet</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">auto</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;/filter&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_classic_filter">Classic Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter takes the output of the <a href="Tokenizers.html#Tokenizers-ClassicTokenizer">Classic Tokenizer</a> and strips periods from acronyms and "'s" from possessives.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ClassicFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ClassicTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ClassicFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "I.B.M. cat&#8217;s can&#8217;t"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "I.B.M", "cat&#8217;s", "can&#8217;t"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "IBM", "cat", "can&#8217;t"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_common_grams_filter">Common Grams Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter creates word shingles by combining common tokens such as stop words with regular tokens. This is useful for creating phrase queries containing common words, such as "the cat." Solr normally ignores stop words in queried phrases, so searching for "the cat" would return all matches for the word "cat."</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.CommonGramsFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>words</code>: (a common word file in .txt format) Provide the name of a common word file, such as <code>stopwords.txt</code>.</p>
</div>
<div class="paragraph">
<p><code>format</code>: (optional) If the stopwords list has been formatted for Snowball, you can specify <code>format="snowball"</code> so Solr can read the stopwords file.</p>
</div>
<div class="paragraph">
<p><code>ignoreCase</code>: (boolean) If true, the filter ignores the case of words when comparing them to the common word file. The default is false.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.CommonGramsFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">stopwords.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "the Cat"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "the", "Cat"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "the_cat"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_collation_key_filter">Collation Key Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Collation allows sorting of text in a language-sensitive way. It is usually used for sorting, but can also be used with advanced searches. We&#8217;ve covered this in much more detail in the section on <a href="Language-Analysis.html#LanguageAnalysis-UnicodeCollation">Unicode Collation</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_daitch_mokotoff_soundex_filter">Daitch-Mokotoff Soundex Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Implements the Daitch-Mokotoff Soundex algorithm, which allows identification of similar names, even if they are spelled differently. More information about how this works is available in the section on <a href="#Phonetic-Matching.adoc">Phonetic Matching</a>.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.DaitchMokotoffSoundexFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>inject</code> : (true/false) If true (the default), then new phonetic tokens are added to the stream. Otherwise, tokens are replaced with the phonetic equivalent. Setting this to false will enable phonetic matching, but the exact spelling of the target word may not match.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.DaitchMokotoffSoundexFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">inject</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_double_metaphone_filter">Double Metaphone Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter creates tokens using the ` DoubleMetaphone ` encoding algorithm from commons-codec. For more information, see the <a href="Phonetic-Matching.html">Phonetic Matching</a> section.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.DoubleMetaphoneFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>inject</code>: (true/false) If true (the default), then new phonetic tokens are added to the stream. Otherwise, tokens are replaced with the phonetic equivalent. Setting this to false will enable phonetic matching, but the exact spelling of the target word may not match.</p>
</div>
<div class="paragraph">
<p><code>maxCodeLength</code>: (integer) The maximum length of the code to be generated.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior for inject (true): keep the original token and add phonetic token(s) at the same position.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.DoubleMetaphoneFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and Kuczewski"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four"(1), "score"(2), "and"(3), "Kuczewski"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "four"(1), "FR"(1), "score"(2), "SKR"(2), "and"(3), "ANT"(3), "Kuczewski"(4), "KSSK"(4), "KXFS"(4)</p>
</div>
<div class="paragraph">
<p>The phonetic tokens have a position increment of 0, which indicates that they are at the same position as the token they were derived from (immediately preceding). Note that "Kuczewski" has two encodings, which are added at the same position.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Discard original token (<code>inject="false"</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.DoubleMetaphoneFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">inject</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and Kuczewski"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four"(1), "score"(2), "and"(3), "Kuczewski"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "FR"(1), "SKR"(2), "ANT"(3), "KSSK"(4), "KXFS"(4)</p>
</div>
<div class="paragraph">
<p>Note that "Kuczewski" has two encodings, which are added at the same position.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_edge_n_gram_filter">Edge N-Gram Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter generates edge n-gram tokens of sizes within the given range.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.EdgeNGramFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>minGramSize</code>: (integer, default 1) The minimum gram size.</p>
</div>
<div class="paragraph">
<p><code>maxGramSize</code>: (integer, default 1) The maximum gram size.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.EdgeNGramFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and twenty"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four", "score", "and", "twenty"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "f", "s", "a", "t"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>A range of 1 to 4.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.EdgeNGramFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">minGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four", "score"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "f", "fo", "fou", "four", "s", "sc", "sco", "scor"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>A range of 4 to 6.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.EdgeNGramFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">minGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">6</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and twenty"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four", "score", "and", "twenty"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "four", "scor", "score", "twen", "twent", "twenty"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_english_minimal_stem_filter">English Minimal Stem Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter stems plural English words to their singular form.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.EnglishMinimalStemFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory </span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.EnglishMinimalStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "dogs cats"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "dogs", "cats"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "dog", "cat"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hunspell_stem_filter">Hunspell Stem Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="http://wiki.apache.org/solr/Hunspell">Hunspell Stem Filter</a> provides support for several languages. You must provide the dictionary (<code>.dic</code>) and rules (<code>.aff</code>) files for each language you wish to use with the Hunspell Stem Filter. You can download those language files <a href="http://wiki.services.openoffice.org/wiki/Dictionaries">here</a>.</p>
</div>
<div class="paragraph">
<p>Be aware that your results will vary widely based on the quality of the provided dictionary and rules files. For example, some languages have only a minimal word list with no morphological information. On the other hand, for languages that have no stemmer but do have an extensive dictionary file, the Hunspell stemmer may be a good choice.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.HunspellStemFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>dictionary</code>: (required) The path of a dictionary file.</p>
</div>
<div class="paragraph">
<p><code>affix</code>: (required) The path of a rules file. <code>ignoreCase</code>: (boolean) controls whether matching is case sensitive or not. The default is false.</p>
</div>
<div class="paragraph">
<p><code>strictAffixParsing</code>: (boolean) controls whether the affix parsing is strict or not. If true, an error while reading an affix rule causes a ParseException, otherwise is ignored. The default is true.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.HunspellStemFilterFactory</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">dictionary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">en_GB.dic</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">affix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">en_GB.aff</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">strictAffixParsing</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "jump jumping jumped"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "jump", "jumping", "jumped"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "jump", "jump", "jump"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hyphenated_words_filter">Hyphenated Words Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter reconstructs hyphenated words that have been tokenized as two tokens because of a line break or other intervening whitespace in the field test. If a token ends with a hyphen, it is joined with the following token and the hyphen is discarded. Note that for this filter to work properly, the upstream tokenizer must not remove trailing hyphen characters. This filter is generally only useful at index time.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.HyphenatedWordsFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.HyphenatedWordsFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "A hyphen- ated word"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "A", "hyphen-", "ated", "word"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "A", "hyphenated", "word"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_icu_folding_filter">ICU Folding Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter is a custom Unicode normalization form that applies the foldings specified in <a href="http://www.unicode.org/reports/tr30/tr30-4.html">Unicode Technical Report 30</a> in addition to the <code>NFKC_Casefold</code> normalization form as described in <a href="#FilterDescriptions-ICUNormalizer2Filter">ICU Normalizer 2 Filter</a>. This filter is a better substitute for the combined behavior of the <a href="#FilterDescriptions-ASCIIFoldingFilter">ASCII Folding Filter</a>, <a href="#FilterDescriptions-LowerCaseFilter">Lower Case Filter</a>, and <a href="#FilterDescriptions-ICUNormalizer2Filter">ICU Normalizer 2 Filter</a>.</p>
</div>
<div class="paragraph">
<p>To use this filter, see <code>solr/contrib/analysis-extras/README.txt</code> for instructions on which jars you need to add to your <code>solr_home/lib</code>.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ICUFoldingFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUFoldingFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For detailed information on this normalization form, see <a href="http://www.unicode.org/reports/tr30/tr30-4.html" class="bare">http://www.unicode.org/reports/tr30/tr30-4.html</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_icu_normalizer_2_filter">ICU Normalizer 2 Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter factory normalizes text according to one of five Unicode Normalization Forms as described in <a href="http://unicode.org/reports/tr15/">Unicode Standard Annex #15</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NFC: (name="nfc" mode="compose") Normalization Form C, canonical decomposition</p>
</li>
<li>
<p>NFD: (name="nfc" mode="decompose") Normalization Form D, canonical decomposition, followed by canonical composition</p>
</li>
<li>
<p>NFKC: (name="nfkc" mode="compose") Normalization Form KC, compatibility decomposition</p>
</li>
<li>
<p>NFKD: (name="nfkc" mode="decompose") Normalization Form KD, compatibility decomposition, followed by canonical composition</p>
</li>
<li>
<p>NFKC_Casefold: (name="nfkc_cf" mode="compose") Normalization Form KC, with additional Unicode case folding. Using the ICU Normalizer 2 Filter is a better-performing substitution for the <a href="#FilterDescriptions-LowerCaseFilter">Lower Case Filter</a> and NFKC normalization.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ICUNormalizer2FilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>name</code>: (string) The name of the normalization form; <code>nfc</code>, <code>nfd</code>, <code>nfkc</code>, <code>nfkd</code>, <code>nfkc_cf</code></p>
</div>
<div class="paragraph">
<p><code>mode</code>: (string) The mode of Unicode character composition and decomposition; <code>compose</code> or <code>decompose</code></p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUNormalizer2FilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">nkc_cf</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">compose</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For detailed information about these Unicode Normalization Forms, see <a href="http://unicode.org/reports/tr15/" class="bare">http://unicode.org/reports/tr15/</a>.</p>
</div>
<div class="paragraph">
<p>To use this filter, see <code>solr/contrib/analysis-extras/README.txt</code> for instructions on which jars you need to add to your <code>solr_home/lib</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_icu_transform_filter">ICU Transform Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter applies <a href="http://userguide.icu-project.org/transforms/general">ICU Tranforms</a> to text. This filter supports only ICU System Transforms. Custom rule sets are not supported.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ICUTransformFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>id</code>: (string) The identifier for the ICU System Transform you wish to apply with this filter. For a full list of ICU System Transforms, see <a href="http://demo.icu-project.org/icu-bin/translit?TEMPLATE_FILE=data/translit_rule_main.html" class="bare">http://demo.icu-project.org/icu-bin/translit?TEMPLATE_FILE=data/translit_rule_main.html</a>.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ICUTransformFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Traditional-Simplified</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For detailed information about ICU Transforms, see <a href="http://userguide.icu-project.org/transforms/general" class="bare">http://userguide.icu-project.org/transforms/general</a>.</p>
</div>
<div class="paragraph">
<p>To use this filter, see <code>solr/contrib/analysis-extras/README.txt</code> for instructions on which jars you need to add to your <code>solr_home/lib</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_keep_words_filter">Keep Words Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter discards all tokens except those that are listed in the given word list. This is the inverse of the Stop Words Filter. This filter can be useful for building specialized indices for a constrained set of terms.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.KeepWordFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>words</code>: (required) Path of a text file containing the list of keep words, one per line. Blank lines and lines that begin with "#" are ignored. This may be an absolute path, or a simple filename in the Solr config directory.</p>
</div>
<div class="paragraph">
<p><code>ignoreCase</code>: (true/false) If <strong>true</strong> then comparisons are done case-insensitively. If this argument is true, then the words file is assumed to contain only lowercase words. The default is <strong>false</strong>.</p>
</div>
<div class="paragraph">
<p><code>enablePositionIncrements</code>: if <code>luceneMatchVersion</code> is <code>4.3</code> or earlier and <code>enablePositionIncrements="false"</code>, no position holes will be left by this filter when it removes tokens. <strong>This argument is invalid if <code>luceneMatchVersion</code> is <code>5.0</code> or later.</strong></p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Where <code>keepwords.txt</code> contains:</p>
</div>
<div class="paragraph">
<p><code>happy</code></p>
</div>
<div class="paragraph">
<p><code>funny</code></p>
</div>
<div class="paragraph">
<p><code>silly</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.KeepWordFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">keepwords.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "Happy, sad or funny"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "Happy", "sad", "or", "funny"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "funny"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Same <code>keepwords.txt</code>, case insensitive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.KeepWordFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">keepwords.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "Happy, sad or funny"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "Happy", "sad", "or", "funny"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "Happy", "funny"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Using LowerCaseFilterFactory before filtering for keep words, no <code>ignoreCase</code> flag.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.KeepWordFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">keepwords.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "Happy, sad or funny"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "Happy", "sad", "or", "funny"</p>
</div>
<div class="paragraph">
<p><strong>Filter to Filter:</strong> "happy", "sad", "or", "funny"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "happy", "funny"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kstem_filter">KStem Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>KStem is an alternative to the Porter Stem Filter for developers looking for a less aggressive stemmer. KStem was written by Bob Krovetz, ported to Lucene by Sergio Guzman-Lara (UMASS Amherst). This stemmer is only appropriate for English language text.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.KStemFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory </span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.KStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "jump jumping jumped"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "jump", "jumping", "jumped"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "jump", "jump", "jump"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_length_filter">Length Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter passes tokens whose length falls within the min/max limit specified. All other tokens are discarded.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.LengthFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>min</code>: (integer, required) Minimum token length. Tokens shorter than this are discarded.</p>
</div>
<div class="paragraph">
<p><code>max</code>: (integer, required, must be &gt;= min) Maximum token length. Tokens longer than this are discarded.</p>
</div>
<div class="paragraph">
<p><code>enablePositionIncrements</code>: if <code>luceneMatchVersion</code> is <code>4.3</code> or earlier and <code>enablePositionIncrements="false"</code>, no position holes will be left by this filter when it removes tokens. <strong>This argument is invalid if <code>luceneMatchVersion</code> is <code>5.0</code> or later.</strong></p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LengthFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">min</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">max</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "turn right at Albuquerque"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "turn", "right", "at", "Albuquerque"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "turn", "right"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lower_case_filter">Lower Case Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Converts any uppercase letters in a token to the equivalent lowercase token. All other characters are left unchanged.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.LowerCaseFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "Down With CamelCase"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "Down", "With", "CamelCase"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "down", "with", "camelcase"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_managed_stop_filter">Managed Stop Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is specialized version of the <a href="#FilterDescriptions-StopFilter">Stop Words Filter Factory</a> that uses a set of stop words that are <a href="Managed-Resources.html">managed from a REST API.</a></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>managed</code>: The name that should be used for this set of stop words in the managed REST API.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>With this configuration the set of words is named "english" and can be managed via <code>/solr/collection_name/schema/analysis/stopwords/english</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ManagedStopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">managed</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#_stop-filter">Stop Filter</a> for example input/output.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_managed_synonym_filter">Managed Synonym Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is specialized version of the <a href="#_synonym-filter">Synonym Filter Factory</a> that uses a mapping on synonyms that is <a href="#Managed-Resources.adoc">managed from a REST API</a>.</p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>managed</code>: The name that should be used for this mapping on synonyms in the managed REST API.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>With this configuration the set of mappings is named "english" and can be managed via <code>/solr/collection_name/schema/analysis/synonyms/english</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ManagedSynonymFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">managed</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#_synonym-filter">Synonym Filter</a> for example input/output.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_n_gram_filter">N-Gram Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Generates n-gram tokens of sizes in the given range. Note that tokens are ordered by position and then by gram size.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.NGramFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>minGramSize</code>: (integer, default 1) The minimum gram size.</p>
</div>
<div class="paragraph">
<p><code>maxGramSize</code>: (integer, default 2) The maximum gram size.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.NGramFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four", "score"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "f", "o", "u", "r", "fo", "ou", "ur", "s", "c", "o", "r", "e", "sc", "co", "or", "re"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>A range of 1 to 4.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.NGramFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">minGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four", "score"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "f", "fo", "fou", "four", "s", "sc", "sco", "scor"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>A range of 3 to 5.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.NGramFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">minGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxGramSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">5</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four", "score"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "fou", "four", "our", "sco", "scor", "score", "cor", "core", "ore"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_numeric_payload_token_filter">Numeric Payload Token Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter adds a numeric floating point payload value to tokens that match a given type. Refer to the Javadoc for the <code>org.apache.lucene.analysis.Token</code> class for more information about token types and payloads.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.NumericPayloadTokenFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>payload</code>: (required) A floating point value that will be added to all matching tokens.</p>
</div>
<div class="paragraph">
<p><code>typeMatch</code>: (required) A token type name string. Tokens with a matching type name will have their payload set to the above floating point value.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.NumericPayloadTokenFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">payload</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0.75</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">typeMatch</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">word</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "bing bang boom"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "bing", "bang", "boom"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "bing"[0.75], "bang"[0.75], "boom"[0.75]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pattern_replace_filter">Pattern Replace Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter applies a regular expression to each token and, for those that match, substitutes the given replacement string in place of the matched pattern. Tokens which do not match are passed though unchanged.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.PatternReplaceFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>pattern</code>: (required) The regular expression to test against each token, as per <code>java.util.regex.Pattern</code>.</p>
</div>
<div class="paragraph">
<p><code>replacement</code>: (required) A string to substitute in place of the matched pattern. This string may contain references to capture groups in the regex pattern. See the Javadoc for <code>java.util.regex.Matcher</code>.</p>
</div>
<div class="paragraph">
<p><code>replace</code>: ("all" or "first", default "all") Indicates whether all occurrences of the pattern in the token should be replaced, or only the first.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Simple string replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PatternReplaceFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pattern</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">cat</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replacement</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dog</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "cat concatenate catycat"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "cat", "concatenate", "catycat"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "dog", "condogenate", "dogydog"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>String replacement, first occurrence only:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PatternReplaceFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pattern</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">cat</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replacement</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dog</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replace</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "cat concatenate catycat"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "cat", "concatenate", "catycat"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "dog", "condogenate", "dogycat"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>More complex pattern with capture group reference in the replacement. Tokens that start with non-numeric characters and end with digits will have an underscore inserted before the numbers. Otherwise the token is passed through.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PatternReplaceFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pattern</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">(\D+)(\d+)$</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replacement</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">$1_$2</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "cat foo1234 9987 blah1234foo"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "cat", "foo1234", "9987", "blah1234foo"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "cat", "foo_1234", "9987", "blah1234foo"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_phonetic_filter">Phonetic Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter creates tokens using one of the phonetic encoding algorithms in the <code>org.apache.commons.codec.language</code> package. For more information, see the section on <a href="https://cwiki.apache.org/confluence/display/solr/Phonetic+Matching">Phonetic Matching</a>.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.PhoneticFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>encoder</code>: (required) The name of the encoder to use. The encoder name must be one of the following (case insensitive): <a href="http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/DoubleMetaphone.html">DoubleMetaphone</a>, <a href="http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/Metaphone.html">Metaphone</a>, <a href="http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/Soundex.html">Soundex</a>, <a href="http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/RefinedSoundex.html">RefinedSoundex</a>, <a href="http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/Caverphone.html">Caverphone (v2.0)</a>, <a href="http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/ColognePhonetic.html">ColognePhonetic</a>, or <a href="http://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/language/Nysiis.html">Nysiis</a>.</p>
</div>
<div class="paragraph">
<p><code>inject</code>: (true/false) If true (the default), then new phonetic tokens are added to the stream. Otherwise, tokens are replaced with the phonetic equivalent. Setting this to false will enable phonetic matching, but the exact spelling of the target word may not match.</p>
</div>
<div class="paragraph">
<p><code>maxCodeLength</code>: (integer) The maximum length of the code to be generated by the Metaphone or Double Metaphone encoders.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior for DoubleMetaphone encoding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PhoneticFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">encoder</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DoubleMetaphone</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and twenty"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four"(1), "score"(2), "and"(3), "twenty"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "four"(1), "FR"(1), "score"(2), "SKR"(2), "and"(3), "ANT"(3), "twenty"(4), "TNT"(4)</p>
</div>
<div class="paragraph">
<p>The phonetic tokens have a position increment of 0, which indicates that they are at the same position as the token they were derived from (immediately preceding).</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Discard original token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PhoneticFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">encoder</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DoubleMetaphone</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">inject</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and twenty"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four"(1), "score"(2), "and"(3), "twenty"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "FR"(1), "SKR"(2), "ANT"(3), "TWNT"(4)</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default Soundex encoder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PhoneticFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">encoder</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Soundex</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "four score and twenty"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "four"(1), "score"(2), "and"(3), "twenty"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "four"(1), "F600"(1), "score"(2), "S600"(2), "and"(3), "A530"(3), "twenty"(4), "T530"(4)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_porter_stem_filter">Porter Stem Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter applies the Porter Stemming Algorithm for English. The results are similar to using the Snowball Porter Stemmer with the <code>language="English"</code> argument. But this stemmer is coded directly in Java and is not based on Snowball. It does not accept a list of protected words and is only appropriate for English language text. However, it has been benchmarked as <a href="http://markmail.org/thread/d2c443z63z37rwf6">four times faster</a> than the English Snowball stemmer, so can provide a performance enhancement.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.PorterStemFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory </span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PorterStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "jump jumping jumped"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "jump", "jumping", "jumped"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "jump", "jump", "jump"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_remove_duplicates_token_filter">Remove Duplicates Token Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The filter removes duplicate tokens in the stream. Tokens are considered to be duplicates if they have the same text and position values.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.RemoveDuplicatesTokenFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>One example of where <code>RemoveDuplicatesTokenFilterFactory</code> is in situations where a synonym file is being used in conjuntion with a stemmer causes some synonyms to be reduced to the same stem. Consider the following entry from a <code>synonyms.txt</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Television, Televisions, TV, TVs</code></pre>
</div>
</div>
<div class="paragraph">
<p>When used in the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SynonymFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">synonyms</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">synonyms.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.EnglishMinimalStemFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.RemoveDuplicatesTokenFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "Watch TV"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Synonym Filter:</strong> "Watch"(1) "TV"(2)</p>
</div>
<div class="paragraph">
<p><strong>Synonym Filter to Stem Filter:</strong> "Watch"(1) "Television"(2) "Televisions"(2) "TV"(2) "TVs"(2)</p>
</div>
<div class="paragraph">
<p><strong>Stem Filter to Remove Dups Filter:</strong> "Watch"(1) "Television"(2) "Television"(2) "TV"(2) "TV"(2)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "Watch"(1) "Television"(2) "TV"(2)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reversed_wildcard_filter">Reversed Wildcard Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter reverses tokens to provide faster leading wildcard and prefix queries. Tokens without wildcards are not reversed.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ReversedWildcardFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>withOriginal</code> (boolean) If true, the filter produces both original and reversed tokens at the same positions. If false, produces only reversed tokens.</p>
</div>
<div class="paragraph">
<p><code>maxPosAsterisk</code> (integer, default = 2) The maximum position of the asterisk wildcard ('*') that triggers the reversal of the query term. Terms with asterisks at positions above this value are not reversed.</p>
</div>
<div class="paragraph">
<p><code>maxPosQuestion</code> (integer, default = 1) The maximum position of the question mark wildcard ('?') that triggers the reversal of query term. To reverse only pure suffix queries (queries with a single leading asterisk), set this to 0 and <code>maxPosAsterisk</code> to 1.</p>
</div>
<div class="paragraph">
<p><code>maxFractionAsterisk</code> (float, default = 0.0) An additional parameter that triggers the reversal if asterisk ('*') position is less than this fraction of the query token length.</p>
</div>
<div class="paragraph">
<p><code>minTrailing</code> (integer, default = 2) The minimum number of trailing characters in a query token after the last wildcard character. For good performance this should be set to a value larger than 1.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ReversedWildcardFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">withOriginal</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">maxPosAsterisk</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxPosQuestion</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">minTrailing</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxFractionAsterisk</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "*foo *bar"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "*foo", "*bar"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "oof*", "rab*"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_shingle_filter">Shingle Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter constructs shingles, which are token n-grams, from the token stream. It combines runs of tokens into a single token.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.ShingleFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>minShingleSize</code>: (integer, default 2) The minimum number of tokens per shingle.</p>
</div>
<div class="paragraph">
<p><code>maxShingleSize</code>: (integer, must be &gt;= 2, default 2) The maximum number of tokens per shingle.</p>
</div>
<div class="paragraph">
<p><code>outputUnigrams</code>: (true/false) If true (the default), then each individual token is also included at its original position.</p>
</div>
<div class="paragraph">
<p><code>outputUnigramsIfNoShingles</code>: (true/false) If false (the default), then individual tokens will be output if no shingles are possible.</p>
</div>
<div class="paragraph">
<p><code>tokenSeparator</code>: (string, default is " ") The default string to use when joining adjacent tokens to form a shingle.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ShingleFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "To be, or what?"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "To"(1), "be"(2), "or"(3), "what"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "To"(1), "To be"(1), "be"(2), "be or"(2), "or"(3), "or what"(3), "what"(4)</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>A shingle size of four, do not include original token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.ShingleFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxShingleSize</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">outputUnigrams</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "To be, or not to be."</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "To"(1), "be"(2), "or"(3), "not"(4), "to"(5), "be"(6)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "To be"(1), "To be or"(1), "To be or not"(1), "be or"(2), "be or not"(2), "be or not to"(2), "or not"(3), "or not to"(3), "or not to be"(3), "not to"(4), "not to be"(4), "to be"(5)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_snowball_porter_stemmer_filter">Snowball Porter Stemmer Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter factory instantiates a language-specific stemmer generated by Snowball. Snowball is a software package that generates pattern-based word stemmers. This type of stemmer is not as accurate as a table-based stemmer, but is faster and less complex. Table-driven stemmers are labor intensive to create and maintain and so are typically commercial products.</p>
</div>
<div class="paragraph">
<p>Solr contains Snowball stemmers for Armenian, Basque, Catalan, Danish, Dutch, English, Finnish, French, German, Hungarian, Italian, Norwegian, Portuguese, Romanian, Russian, Spanish, Swedish and Turkish. For more information on Snowball, visit <a href="http://snowball.tartarus.org/" class="bare">http://snowball.tartarus.org/</a>.</p>
</div>
<div class="paragraph">
<p><code>StopFilterFactory</code>, <code>CommonGramsFilterFactory</code>, and <code>CommonGramsQueryFilterFactory</code> can optionally read stopwords in Snowball format (specify <code>format="snowball"</code> in the configuration of those FilterFactories).</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.SnowballPorterFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>language</code>: (default "English") The name of a language, used to select the appropriate Porter stemmer to use. Case is significant. This string is used to select a package name in the "org.tartarus.snowball.ext" class hierarchy.</p>
</div>
<div class="paragraph">
<p><code>protected</code>: Path of a text file containing a list of protected words, one per line. Protected words will not be stemmed. Blank lines and lines that begin with "#" are ignored. This may be an absolute path, or a simple file name in the Solr config directory.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "flip flipped flipping"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "flip", "flipped", "flipping"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "flip", "flip", "flip"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>French stemmer, English words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">French</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "flip flipped flipping"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "flip", "flipped", "flipping"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "flip", "flipped", "flipping"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Spanish stemmer, Spanish words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SnowballPorterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">language</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Spanish</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "cante canta"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "cante", "canta"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "cant", "cant"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_standard_filter">Standard Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter removes dots from acronyms and the substring "'s" from the end of tokens. This filter depends on the tokens being tagged with the appropriate term-type to recognize acronyms and words with apostrophes.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.StandardFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p>Note:</p>
</div>
<div class="paragraph">
<p>This filter is no longer operational in Solr when the <code>luceneMatchVersion</code> (in <code>solrconfig.xml</code>) is higher than "3.1".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_stop_filter">Stop Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter discards, or <em>stops</em> analysis of, tokens that are on the given stop words list. A standard stop words list is included in the Solr config directory, named <code>stopwords.txt</code>, which is appropriate for typical English language text.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.StopFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>words</code>: (optional) The path to a file that contains a list of stop words, one per line. Blank lines and lines that begin with "#" are ignored. This may be an absolute path, or path relative to the Solr config directory.</p>
</div>
<div class="paragraph">
<p><code>format</code>: (optional) If the stopwords list has been formatted for Snowball, you can specify <code>format="snowball"</code> so Solr can read the stopwords file.</p>
</div>
<div class="paragraph">
<p><code>ignoreCase</code>: (true/false, default false) Ignore case when testing for stop words. If true, the stop list should contain lowercase words.</p>
</div>
<div class="paragraph">
<p><code>enablePositionIncrements</code>: if <code>luceneMatchVersion</code> is <code>4.4</code> or earlier and <code>enablePositionIncrements="false"</code>, no position holes will be left by this filter when it removes tokens. <strong>This argument is invalid if <code>luceneMatchVersion</code> is <code>5.0</code> or later.</strong></p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Case-sensitive matching, capitalized words not stopped. Token positions skip stopped words.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">stopwords.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "To be or what?"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "To"(1), "be"(2), "or"(3), "what"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "To"(1), "what"(4)</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">stopwords.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "To be or what?"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "To"(1), "be"(2), "or"(3), "what"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "what"(4)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_suggest_stop_filter">Suggest Stop Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like <a href="#_stop-filter">Stop Filter</a>, this filter discards, or <em>stops</em> analysis of, tokens that are on the given stop words list. Suggest Stop Filter differs from Stop Filter in that it will not remove the last token unless it is followed by a token separator. For example, a query &#8220;find the&#8221; would preserve the &#8216;the&#8217; since it was not followed by a space, punctuation etc., and mark it as a <code>KEYWORD</code> so that following filters will not change or remove it. By contrast, a query like &#8220;find the popsicle&#8221; would remove &#8220;the&#8221; as a stopword, since it&#8217;s followed by a space. When using one of the analyzing suggesters, you would normally use the ordinary <code>StopFilterFactory</code> in your index analyzer and then SuggestStopFilter in your query analyzer.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.SuggestStopFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>words</code>: (optional; default: ` StopAnalyzer#ENGLISH_STOP_WORDS_SET `) The name of a stopwords file to parse.</p>
</div>
<div class="paragraph">
<p><code>format</code>: (optional; default: <code>wordset</code>) Defines how the words file will be parsed. If <code>words</code> is not specified, then <code>format</code> must not be specified. The valid values for the format option are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wordset</code>: This is the default format, which supports one word per line (including any intra-word whitespace) and allows whole line comments begining with the &#8220;#&#8221; character. Blank lines are ignored.</p>
</li>
<li>
<p><code>snowball</code>: This format allows for multiple words specified on each line, and trailing comments may be specified using the vertical line (&#8220;|&#8221;). Blank lines are ignored.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ignoreCase</code>: (optional; default: <code>false</code>) If <code>true</code>, matching is case-insensitive.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.LowerCaseFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SuggestStopFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ignoreCase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">words</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">stopwords.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">format</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">wordset</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "The The"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "the"(1), "the"(2)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "the"(2)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synonym_filter">Synonym Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter does synonym mapping. Each token is looked up in the list of synonyms and if a match is found, then the synonym is emitted in place of the token. The position value of the new tokens are set such they all occur at the same position as the original token.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.SynonymFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>synonyms</code>: (required) The path of a file that contains a list of synonyms, one per line. In the (default) <code>solr</code> format - see the <code>format</code> argument below for alternatives - blank lines and lines that begin with &#8220;#&#8221; are ignored. This may be an absolute path, or path relative to the Solr config directory. There are two ways to specify synonym mappings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A comma-separated list of words. If the token matches any of the words, then all the words in the list are substituted, which will include the original token.</p>
</li>
<li>
<p>Two comma-separated lists of words with the symbol "&#8658;" between them. If the token matches any word on the left, then the list on the right is substituted. The original token will not be included unless it is also in the list on the right.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ignoreCase</code>: (optional; default: <code>false</code>) If <code>true</code>, synonyms will be matched case-insensitively.</p>
</div>
<div class="paragraph">
<p><code>expand</code>: (optional; default: <code>true</code>) If <code>true</code>, a synonym will be expanded to all equivalent synonyms. If <code>false</code>, all equivalent synonyms will be reduced to the first in the list.</p>
</div>
<div class="paragraph">
<p><code>format</code>: (optional; default: <code>solr</code>) Controls how the synonyms will be parsed. The short names <code>solr</code> (for ` SolrSynonymParser)` and <code>wordnet</code> (for ` WordnetSynonymParser `) are supported, or you may alternatively supply the name of your own ` SynonymMap.Builder ` subclass.</p>
</div>
<div class="paragraph">
<p><code>tokenizerFactory</code>: (optional; default: <code>WhitespaceTokenizerFactory</code>) The name of the tokenizer factory to use when parsing the synonyms file. Arguments with the name prefix &#8220;tokenizerFactory."` will be supplied as init params to the specified tokenizer factory. Any arguments not consumed by the synonym filter factory, including those without the "`tokenizerFactory.&#8221; prefix, will also be supplied as init params to the tokenizer factory. If <code>tokenizerFactory</code> is specified, then <code>analyzer</code> may not be, and vice versa.</p>
</div>
<div class="paragraph">
<p><code>analyzer</code>: (optional; default: <code>WhitespaceTokenizerFactory</code>) The name of the analyzer class to use when parsing the synonyms file. If <code>analyzer</code> is specified, then <code>tokenizerFactory</code> may not be, and vice versa.</p>
</div>
<div class="paragraph">
<p>For the following examples, assume a synonyms file named <code>mysynonyms.txt</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>couch,sofa,divan
teh =&gt; the
huge,ginormous,humungous =&gt; large
small =&gt; tiny,teeny,weeny</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SynonymFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">synonyms</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mysynonyms.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "teh small couch"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "teh"(1), "small"(2), "couch"(3)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "the"(1), "tiny"(2), "teeny"(2), "weeny"(2), "couch"(3), "sofa"(3), "divan"(3)</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.StandardTokenizerFactory </span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.SynonymFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">synonyms</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mysynonyms.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "teh ginormous, humungous sofa"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "teh"(1), "ginormous"(2), "humungous"(3), "sofa"(4)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "the"(1), "large"(2), "large"(3), "couch"(4), "sofa"(4), "divan"(4)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_token_offset_payload_filter">Token Offset Payload Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter adds the numeric character offsets of the token as a payload value for that token.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.TokenOffsetPayloadTokenFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TokenOffsetPayloadTokenFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "bing bang boom"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "bing", "bang", "boom"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "bing"[0,4], "bang"[5,9], "boom"[10,14]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_trim_filter">Trim Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter trims leading and/or trailing whitespace from tokens. Most tokenizers break tokens at whitespace, so this filter is most often used for special situations.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.TrimFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>updateOffsets</code>: if <code>luceneMatchVersion</code> is <code>4.3</code> or earlier and <code>updateOffsets="true"</code>, trimmed tokens' start and end offsets will be updated to those of the first and last characters (plus one) remaining in the token. <strong>This argument is invalid if <code>luceneMatchVersion</code> is <code>5.0</code> or later.</strong></p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>The PatternTokenizerFactory configuration used here splits the input on simple commas, it does not remove whitespace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.PatternTokenizerFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pattern</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">,</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TrimFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "one, two , three ,four "</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "one", " two ", " three ", "four "</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "one", "two", "three", "four"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_as_payload_filter">Type As Payload Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter adds the token&#8217;s type, as an encoded byte sequence, as its payload.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.TypeAsPayloadTokenFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong> None</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TypeAsPayloadTokenFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "Pay Bob&#8217;s I.O.U."</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "Pay", "Bob&#8217;s", "I.O.U."</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "Pay"[&lt;ALPHANUM&gt;], "Bob&#8217;s"[&lt;APOSTROPHE&gt;], "I.O.U."[&lt;ACRONYM&gt;]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_token_filter">Type Token Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter blacklists or whitelists a specified list of token types, assuming the tokens have type metadata associated with them. For example, the <a href="Tokenizers.html#_UAX29-URL-Email-Tokenizer">UAX29 URL Email Tokenizer</a> emits "&lt;URL&gt;" and "&lt;EMAIL&gt;" typed tokens, as well as other types. This filter would allow you to pull out only e-mail addresses from text as tokens, if you wish.</p>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.TypeTokenFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>types</code>: Defines the location of a file of types to filter.</p>
</div>
<div class="paragraph">
<p><code>useWhitelist</code>: If <strong>true</strong>, the file defined in <code>types</code> should be used as include list. If <strong>false</strong>, or undefined, the file defined in <code>types</code> is used as a blacklist.</p>
</div>
<div class="paragraph">
<p><code>enablePositionIncrements</code>: if <code>luceneMatchVersion</code> is <code>4.3</code> or earlier and <code>enablePositionIncrements="false"</code>, no position holes will be left by this filter when it removes tokens. <strong>This argument is invalid if <code>luceneMatchVersion</code> is <code>5.0</code> or later.</strong></p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.TypeTokenFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">types</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">stoptypes.txt</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">useWhitelist</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_word_delimiter_filter">Word Delimiter Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This filter splits tokens at word delimiters. The rules for determining delimiters are determined as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A change in case within a word: "CamelCase" <strong>&#8594;</strong> "Camel", "Case". This can be disabled by setting <code>splitOnCaseChange="0"</code>.</p>
</li>
<li>
<p>A transition from alpha to numeric characters or vice versa: "Gonzo5000" <strong>&#8594;</strong> "Gonzo", "5000" "4500XL" <strong>&#8594;</strong> "4500", "XL". This can be disabled by setting <code>splitOnNumerics="0"</code>.</p>
</li>
<li>
<p>Non-alphanumeric characters (discarded): "hot-spot" <strong>&#8594;</strong> "hot", "spot"</p>
</li>
<li>
<p>A trailing "'s" is removed: "O&#8217;Reilly&#8217;s" <strong>&#8594;</strong> "O", "Reilly"</p>
</li>
<li>
<p>Any leading or trailing delimiters are discarded: "--hot-spot--" <strong>&#8594;</strong> "hot", "spot"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Factory class:</strong> <code>solr.WordDelimiterFilterFactory</code></p>
</div>
<div class="paragraph">
<p><strong>Arguments:</strong></p>
</div>
<div class="paragraph">
<p><code>generateWordParts</code>: (integer, default 1) If non-zero, splits words at delimiters. For example:"CamelCase", "hot-spot" <strong>&#8594;</strong> "Camel", "Case", "hot", "spot"</p>
</div>
<div class="paragraph">
<p><code>generateNumberParts</code>: (integer, default 1) If non-zero, splits numeric strings at delimiters:"1947-32" <strong>&#8594;</strong>"1947", "32"</p>
</div>
<div class="paragraph">
<p><code>splitOnCaseChange</code>: (integer, default 1) If 0, words are not split on camel-case changes:"BugBlaster-XL" <strong>&#8594;</strong> "BugBlaster", "XL". Example 1 below illustrates the default (non-zero) splitting behavior.</p>
</div>
<div class="paragraph">
<p><code>splitOnNumerics</code>: (integer, default 1) If 0, don&#8217;t split words on transitions from alpha to numeric:"FemBot3000" <strong>&#8594;</strong> "Fem", "Bot3000"</p>
</div>
<div class="paragraph">
<p><code>catenateWords</code>: (integer, default 0) If non-zero, maximal runs of word parts will be joined: "hot-spot-sensor&#8217;s" <strong>&#8594;</strong> "hotspotsensor"</p>
</div>
<div class="paragraph">
<p><code>catenateNumbers</code>: (integer, default 0) If non-zero, maximal runs of number parts will be joined: 1947-32" <strong>&#8594;</strong> "194732"</p>
</div>
<div class="paragraph">
<p><code>catenateAll</code>: (0/1, default 0) If non-zero, runs of word and number parts will be joined: "Zap-Master-9000" <strong>&#8594;</strong> "ZapMaster9000"</p>
</div>
<div class="paragraph">
<p><code>preserveOriginal</code>: (integer, default 0) If non-zero, the original token is preserved: "Zap-Master-9000" <strong>&#8594;</strong> "Zap-Master-9000", "Zap", "Master", "9000"</p>
</div>
<div class="paragraph">
<p><code>protected</code>: (optional) The pathname of a file that contains a list of protected words that should be passed through without splitting.</p>
</div>
<div class="paragraph">
<p><code>stemEnglishPossessive</code>: (integer, default 1) If 1, strips the possessive "'s" from each subword.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Default behavior. The whitespace tokenizer is used here to preserve non-alphanumeric characters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WordDelimiterFilterFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "hot-spot RoboBlaster/9000 100XL"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "hot-spot", "RoboBlaster/9000", "100XL"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "hot", "spot", "Robo", "Blaster", "9000", "100", "XL"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Do not split on case changes, and do not generate number parts. Note that by not generating number parts, tokens containing only numeric parts are ultimately discarded.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WordDelimiterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">generateNumberParts</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">splitOnCaseChange</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "hot-spot RoboBlaster/9000 100-42"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "hot-spot", "RoboBlaster/9000", "100-42"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "hot", "spot", "RoboBlaster", "9000"</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Concatenate word parts and number parts, but not word and number parts that occur in the same token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WordDelimiterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">catenateWords</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">catenateNumbers</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "hot-spot 100+42 XL40"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "hot-spot"(1), "100+42"(2), "XL40"(3)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "hot"(1), "spot"(2), "hotspot"(2), "100"(3), "42"(4), "10042"(4), "XL"(5), "40"(6)</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Concatenate all. Word and/or number parts are joined together.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WordDelimiterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">catenateAll</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "XL-4000/ES"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "XL-4000/ES"(1)</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "XL"(1), "4000"(2), "ES"(3), "XL4000ES"(3)</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Using a protected words list that contains "AstroBlaster" and "XL-5000" (among others).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;analyzer&gt;</span>
  <span class="tag">&lt;tokenizer</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WhitespaceTokenizerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;filter</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">solr.WordDelimiterFilterFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">protected</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">protwords.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/analyzer&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>In:</strong> "FooBar AstroBlaster XL-5000 ==ES-34-"</p>
</div>
<div class="paragraph">
<p><strong>Tokenizer to Filter:</strong> "FooBar", "AstroBlaster", "XL-5000", "==ES-34-"</p>
</div>
<div class="paragraph">
<p><strong>Out:</strong> "FooBar", "FooBar", "AstroBlaster", "XL-5000", "ES", "34"</p>
</div>
</div>
</div></p>

	<hr />

	<script type="text/javascript"><!--//--><![CDATA[//><!--
	    var comments_shortname = 'solrcwiki';
	    var comments_identifier = 'Filter Descriptions'; // Insert your unique page ID here
	    (function(w, d) {
		    d.write('<div id="comments_thread"><\/div>');
		    var s = d.createElement('script');
		    s.type = 'text/javascript';
		    s.async = true;
		    s.src = 'https://comments.apache.org/show_comments.lua?site=' + comments_shortname + '&page=' + comments_identifier + '&oldschool=true';
		    (d.getElementsByTagName('head')[0] || d.getElementsByTagName('body')[0]).appendChild(s);
	    })(window, document);
	    //--><!]]></script>
	    <noscript>
	    <iframe width="100%" height="500" src="https://comments.apache.org/iframe.lua?site=solrcwiki&amp;page=Filter Descriptions&oldschool=true"></iframe>
	    </noscript>

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2016 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.4.0</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>

  </body>
</html>
